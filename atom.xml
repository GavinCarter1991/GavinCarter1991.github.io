<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gavin&#39;s Blog</title>
  
  <subtitle>记录成长过程中的点点滴滴</subtitle>
  <link href="https://kindyourself.github.io/atom.xml" rel="self"/>
  
  <link href="https://kindyourself.github.io/"/>
  <updated>2025-06-09T08:25:52.896Z</updated>
  <id>https://kindyourself.github.io/</id>
  
  <author>
    <name>kindyourself@163.com</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Widget进阶</title>
    <link href="https://kindyourself.github.io/2025/06/07/widget-advanced/"/>
    <id>https://kindyourself.github.io/2025/06/07/widget-advanced/</id>
    <published>2025-06-07T12:17:56.000Z</published>
    <updated>2025-06-09T08:25:52.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Widget-介绍"><a href="#1-Widget-介绍" class="headerlink" title="1.Widget 介绍"></a>1.Widget 介绍</h2><blockquote><p>Everything is a widget 这是你学习 flutter 会听到的最多的一句话。因为在 Flutter 中几乎所有的对象都是一个 widget，在 flutter 中 UI 的构建和事件的处理基本都是通过 widget 的组合及嵌套来完成的。在 iOS 中我们经常提及的“组件”、“控件”在 flutter 中就是 widget，当然 widget 的范围比之更加广泛。如：手势检测 GestureDetector、主题 Theme 和动画容器 AnimatedContainer 等也是 widget。</p></blockquote><p><strong>Flutter 默认支持的两种设计风格：</strong></p><blockquote><p><strong>1.Material components Design：</strong> 谷歌（android）的 UI 风格，主要为 Android 设计，但也支持跨平台使用。</p></blockquote><blockquote><p><strong>2.Cupertino Design：</strong> 苹果（iOS）的 UI 风格，模仿苹果原生 UIKit 风格。高度还原 iOS 原生体验，适合需要与苹果生态一致的应用。</p></blockquote><h2 id="2-Widget-分类"><a href="#2-Widget-分类" class="headerlink" title="2.Widget 分类"></a>2.Widget 分类</h2><p><strong><em>1.按状态管理</em></strong></p><h6 id="一、StatelessWidget："><a href="#一、StatelessWidget：" class="headerlink" title="一、StatelessWidget："></a>一、StatelessWidget：</h6><p>无状态组件，通过 build 方法返回静态 UI。不可变，属性（final）在创建后无法修改，适用于不需要内部状态变化的场景（如文本显示、图标），不依赖用户交互或数据变化的 UI 部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class IconTextButton extends StatelessWidget &#123;</span><br><span class="line">  final String iconName;</span><br><span class="line">  final String label;</span><br><span class="line">  final VoidCallback onPressed;</span><br><span class="line"></span><br><span class="line">  const IconTextButton(&#123;</span><br><span class="line">    super.key,</span><br><span class="line">    required this.iconName,</span><br><span class="line">    required this.label,</span><br><span class="line">    required this.onPressed,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return GestureDetector(</span><br><span class="line">      onTap: onPressed,</span><br><span class="line">      child: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Image.asset(</span><br><span class="line">            &quot;assets/images/$iconName.png&quot;,</span><br><span class="line">            width: 40,</span><br><span class="line">            height: 40,</span><br><span class="line">          ),</span><br><span class="line">          const SizedBox(</span><br><span class="line">            height: 10,</span><br><span class="line">          ), // 图标</span><br><span class="line">          Text(</span><br><span class="line">            label,</span><br><span class="line">            style: const TextStyle(color: ColorConstant.color33, fontSize: 10),</span><br><span class="line">          ), // 文字</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="二、StatefulWidget："><a href="#二、StatefulWidget：" class="headerlink" title="二、StatefulWidget："></a>二、StatefulWidget：</h6><p>有状态组件，通过 State 对象管理动态数据。当状态变化时调用 setState 触发 UI 更新，需要用户交互（如按钮点击、表单输入）和依赖实时数据变化（如计数器、动态列表）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 上下滚动的消息轮播</span><br><span class="line">class MarqueeWidget extends StatefulWidget &#123;</span><br><span class="line">  /// 子视图数量</span><br><span class="line">  final int count;</span><br><span class="line"></span><br><span class="line">  ///子视图构建器</span><br><span class="line">  final IndexedWidgetBuilder itemBuilder;</span><br><span class="line"></span><br><span class="line">  ///轮播的时间间隔</span><br><span class="line">  final int loopSeconds;</span><br><span class="line"></span><br><span class="line">  const MarqueeWidget(&#123;</span><br><span class="line">    super.key,</span><br><span class="line">    required this.count,</span><br><span class="line">    required this.itemBuilder,</span><br><span class="line">    this.loopSeconds = 5,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MarqueeWidgetState createState() =&gt; _MarqueeWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MarqueeWidgetState extends State&lt;MarqueeWidget&gt; &#123;</span><br><span class="line">  late PageController _controller;</span><br><span class="line">  late Timer _timer;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    _controller = PageController();</span><br><span class="line">    _timer = Timer.periodic(Duration(seconds: widget.loopSeconds), (timer) &#123;</span><br><span class="line">      if (_controller.page != null) &#123;</span><br><span class="line">        // 如果当前位于最后一页，则直接跳转到第一页，两者内容相同，跳转时视觉上无感知</span><br><span class="line">        if (_controller.page!.round() &gt;= widget.count) &#123;</span><br><span class="line">          _controller.jumpToPage(0);</span><br><span class="line">        &#125;</span><br><span class="line">        _controller.nextPage(</span><br><span class="line">            duration: const Duration(seconds: 1), curve: Curves.linear);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return PageView.builder(</span><br><span class="line">      scrollDirection: Axis.vertical,</span><br><span class="line">      controller: _controller,</span><br><span class="line">      itemBuilder: (buildContext, index) &#123;</span><br><span class="line">        if (index &lt; widget.count) &#123;</span><br><span class="line">          return widget.itemBuilder(buildContext, index);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return widget.itemBuilder(buildContext, 0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      itemCount: widget.count + 1,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    super.dispose();</span><br><span class="line">    _controller.dispose();</span><br><span class="line">    _timer.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><em>2.按功能分类</em></strong></p><blockquote><p><strong>1.布局类 Widget：</strong> 控制子 Widget 的排列方式。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Row/Column：水平/垂直排列子项（基于 Flexbox）。</span><br><span class="line">Stack：子 Widget 堆叠（类似 CSS 的绝对定位）。</span><br><span class="line">Expanded/Flexible：在 Row 或 Column 中分配剩余空间。</span><br><span class="line">Container：结合布局、装饰、边距等功能</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>2.基础组件 Widget：</strong> 构成 UI 的基本元素。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Text：显示文本。</span><br><span class="line">Image：加载本地或网络图片。</span><br><span class="line">Icon：显示图标（需引入 cupertino_icons 或自定义图标库）</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>3.滚动类 Widget：</strong> 处理内容超出屏幕时的滚动行为。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">ListView：垂直/水平滚动列表。</span><br><span class="line">GridView：网格布局滚动视图。</span><br><span class="line">SingleChildScrollView：包裹单个可滚动子组件。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>4.交互类 Widget：</strong> 响应用户输入事件。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">ElevatedButton/TextButton：按钮交互。</span><br><span class="line">TextField：文本输入框。</span><br><span class="line">Checkbox/Switch：选择控件。</span><br><span class="line">GestureDetector：自定义手势检测（点击、长按、拖动）。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>5.平台风格类 Widget：</strong> 适配不同操作系统的视觉风格。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Material Design：MaterialApp、AppBar、FloatingActionButton。</span><br><span class="line">Cupertino（iOS 风格）：CupertinoApp、CupertinoNavigationBar、CupertinoPicker。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>6.动画类 Widget：</strong> 实现动态视觉效果。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">AnimatedContainer：自动过渡的容器（大小、颜色等属性变化）。</span><br><span class="line">Hero：页面切换共享元素的过渡动画。</span><br><span class="line">AnimatedBuilder：自定义复杂动画。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>7. 导航与路由类 Widget：</strong> 管理页面跳转和导航结构。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Navigator：管理页面堆栈（push/pop）。</span><br><span class="line">PageView：实现滑动切换页面。</span><br><span class="line">BottomNavigationBar：底部导航栏。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>通过简单 Widget 组合实现复杂 UI（例如用 Row + Expanded 替代自定义布局）(优先组合而非继承)<br>局部状态使用 StatefulWidget<br>全局状态使用状态管理工具（如 Provider、Riverpod）<br>对频繁更新的部分使用 const 构造函数<br>长列表使用 ListView.builder 懒加载</p></blockquote><h2 id="3-Widget-生命周期"><a href="#3-Widget-生命周期" class="headerlink" title="3.Widget 生命周期"></a>3.Widget 生命周期</h2><p><strong>StatelessWidget 的生命周期</strong></p><blockquote><p>StatelessWidget 仅有一个 build() 方法，无状态管理逻辑，其生命周期完全由父组件控制。</p></blockquote><p><strong>StatefulWidget 主要生命周期方法</strong></p><blockquote><p>创建阶段<br>createState()</p></blockquote><blockquote><p>初始化阶段<br>initState()<br>didChangeDependencies()</p></blockquote><blockquote><p>更新阶段<br>didUpdateWidget(oldWidget)<br>build()</p></blockquote><blockquote><p>销毁阶段<br>deactivate()<br>dispose()</p></blockquote><p><img src="https://i-blog.csdnimg.cn/img_convert/a33469c55f94b5278f698d8605d8e0cc.webp?x-oss-process=image/format,png" alt="2025-05-22 18.38.22.png"></p><p><strong>1.createState()</strong><br>当 StatefulWidget 被插入 Widget 树时调用，而且只执行一次。</p><blockquote><p>主要用于创建与之关联的 State 对象（每个 Widget 对应一个 State 实例）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyWidget extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _MyWidgetState createState() =&gt; _MyWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.initState()</strong><br>在 State 对象创建后，首次调用 build() 之前触发该方法，而且只执行一次。</p><blockquote><p>主要用于初始化依赖数据（如订阅事件、加载本地配置）和 创建动画控制器（AnimationController）等需与 dispose() 配对的资源。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  super.initState();</span><br><span class="line">  _controller = AnimationController(vsync: this);</span><br><span class="line">  _fetchData(); // 初始化数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是：<br><code>必须调用 super.initState()。</code><br><code>在这里 View 并没有渲染，只是 StatefulWidget 被加载到渲染树里了。</code><br><code>避免在此处触发 setState（可能导致渲染未完成）。</code><br><code>StatefulWidget的 mount 的值变为了true（调用dispose()才会变为 false）。</code></p><p><strong>3.didChangeDependencies()</strong><br>initState() 后立即调用 didChangeDependencies()。<br>当 State 依赖的 InheritedWidget 发生变化时（如主题、本地化）也会调用 didChangeDependencies()。</p><blockquote><p>主要用于处理依赖变化后的逻辑（如重新请求网络数据）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void didChangeDependencies() &#123;</span><br><span class="line">  super.didChangeDependencies();</span><br><span class="line">  if (Provider.of&lt;Data&gt;(context).hasChanged) &#123;</span><br><span class="line">    _updateData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4. didUpdateWidget(oldWidget)</strong><br>在父组件重建时，若新旧 Widget 的 runtimeType 和 key 相同触发 didUpdateWidget（didUpdateWidget 我们一般不会用到）。</p><blockquote><p>主要是：<br>对比新旧 Widget 的配置（如属性变化）。<br>根据变化调整状态（如重置动画、更新监听）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void didUpdateWidget(MyWidget oldWidget) &#123;</span><br><span class="line">  super.didUpdateWidget(oldWidget);</span><br><span class="line">  if (oldWidget.color != widget.color) &#123;</span><br><span class="line">    _updateColor(); // 颜色变化时执行逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5. build()</strong><br>初始化后、依赖变化后、setState() 调用后调用 build()。<br>父组件或祖先组件触发重建时调用 build()。</p><blockquote><p>主要是根据当前状态构建 UI（不要在这里做除了创建 Widget 之外的操作）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Container(</span><br><span class="line">    color: widget.color,</span><br><span class="line">    child: Text(&#x27;Count: $_count&#x27;),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是：<br><code>必须返回一个 Widget</code><br><code>避免在此处修改状态或执行耗时操作</code></p><p><strong>6. deactivate()</strong><br>当 State 从树中暂时移除（如页面切换、组件被移除）触发 deactivate()。</p><blockquote><p>清理临时资源或保存临时状态.</p></blockquote><p>需要注意的是：<br><code>可能被重新插入树中（如页面返回时），需与 dispose() 区分</code></p><p><strong>7. dispose()</strong><br>State 被永久移除时调用 dispose()。</p><blockquote><p>释放资源（如取消网络请求、销毁动画控制器）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void dispose() &#123;</span><br><span class="line">  _controller.dispose(); // 销毁动画控制器</span><br><span class="line">  _subscription.cancel(); // 取消事件订阅</span><br><span class="line">  super.dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是：<br><code>如果在 dispose() 中未释放资源（如动画控制器、Stream 订阅）可能造成内存泄漏</code><br><code>如果在 dispose() 后调用 setState 会导致异常</code></p><h2 id="4-Widget-的渲染"><a href="#4-Widget-的渲染" class="headerlink" title="4.Widget 的渲染"></a>4.Widget 的渲染</h2><p><strong>渲染流程：</strong><br>Flutter 的渲染系统基于三棵核心树结构，通过高度优化的管线（Pipeline）实现高效的 UI 更新。</p><blockquote><p><strong>Widget 重建 → Diff 新旧 Widget 树 → 更新 Element 树 → 更新 RenderObject 树 → 触发 Layer 合成 → 屏幕刷新</strong></p></blockquote><p><strong>1.Widget 树的构建：</strong></p><blockquote><p>描述 UI 的不可变配置，由开发者创建，频繁重建，需轻量化。<br>开发者编写的 Widget 代码被转化为嵌套的 Widget 树（应用的入口是根 Widget，一般是 MaterialApp 或 CupertinoApp。根 Widget 会递归地构建其子 Widget，形成一棵树。）。<br>具有不可变性，每次重建生成全新的 Widget 树，但通过 Diff 算法可以优化实际更新范围。</p></blockquote><p><strong>2. Element 树的 Diff 与更新</strong></p><blockquote><p>根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 Element 类。<br>Element 是 Widget 的实例化对象，负责管理 状态（State） 和 子节点引用。<br>每个 Widget 都会有一个对应的 Element 对象，用于管理其生命周期。</p></blockquote><blockquote><p>Diff 算法：Flutter 对比新旧 Widget 树，仅更新变化的 Element 和 RenderObject，类似 React 的虚拟 DOM。<br>当 Widget 树重建时，Flutter 通过 Diff 算法 对比新旧 Widget 树，决定 Element 树的更新策略<br>Reuse：若新旧 Widget 的 runtimeType 和 key 相同，复用现有 Element。<br>Update：更新 Element 的配置（调用 Element.update(newWidget)）。<br>Replace：类型或 Key 不同时，销毁旧 Element，创建新 Element。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 旧 Widget 树</span><br><span class="line">Container(color: Colors.red)</span><br><span class="line"></span><br><span class="line">// 新 Widget 树</span><br><span class="line">Container(color: Colors.blue)</span><br><span class="line"></span><br><span class="line">// Diff 结果：Container 类型相同且无 Key → 复用 Element，更新 RenderObject 颜色</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Element 更新逻辑</span><br><span class="line">Element.updateChild()</span><br><span class="line"></span><br><span class="line">Element updateChild(Element child, Widget newWidget, dynamic newSlot) &#123;</span><br><span class="line">  if (newWidget == null) &#123;</span><br><span class="line">    // 移除子节点</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  if (child != null) &#123;</span><br><span class="line">    if (child.widget == newWidget) &#123;</span><br><span class="line">      // Widget 未变化 → 复用 Element</span><br><span class="line">      return child;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">      // 更新 Element 配置</span><br><span class="line">      child.update(newWidget);</span><br><span class="line">      return child;</span><br><span class="line">    &#125;</span><br><span class="line">    // 销毁旧 Element，创建新 Element</span><br><span class="line">    deactivateChild(child);</span><br><span class="line">  &#125;</span><br><span class="line">  return inflateWidget(newWidget, newSlot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3. RenderObject 树的更新</strong></p><p>更新 RenderObject 树，计算布局和生成绘制指令。<br>运行在 UI Thread。</p><blockquote><p>根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自 RenderObject 类。<br>每个 Element 对应一个 RenderObject（通过 Element.createRenderObject() 创建）。</p></blockquote><blockquote><p>根据父 RenderObject 传递的 约束（Constraints），计算自身尺寸和位置。<br>递归调用子节点的 layout() 方法（深度优先遍历）。</p></blockquote><p><strong>布局（Layout）核心方法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// RenderObject 布局流程</span><br><span class="line">RenderObject.layout()</span><br><span class="line"></span><br><span class="line">void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123;</span><br><span class="line">  _constraints = constraints;</span><br><span class="line">  if (_relayoutBoundary != this) &#123;</span><br><span class="line">    markNeedsLayout();</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  performLayout();  // 1. 计算自身尺寸（调用 performLayout） 由子类实现具体布局逻辑</span><br><span class="line">  _needsLayout = false;</span><br><span class="line">  markNeedsPaint(); // 标记需要重绘</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>生成绘制指令（如形状、颜色、文本），写入 Layer（合成层）。</p></blockquote><p><strong>绘制（Paint）核心方法:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  // 绘制逻辑，如画矩形</span><br><span class="line">  context.canvas.drawRect(rect, paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4. 合成与光栅化（Composition &amp; Rasterization）</strong></p><p>生成 Layer 树并光栅化。<br>运行在 Raster Thread（与 UI Thread 并行）</p><blockquote><p>根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 Layer 类。<br>RenderObject 的绘制结果被组织为 Layer 树，每个 Layer 对应一个 GPU 纹理（Texture）。自此 Layer 树生成。<br>类型包括：PictureLayer（矢量绘制）、TextureLayer（图像纹理）、TransformLayer（变换效果）等。</p></blockquote><blockquote><p>将 Layer 树中的绘制指令转换为 GPU 可识别的位图数据。<br>通过 Skia 图形库（或 Impeller）完成，最终提交给 GPU 渲染。（完成光栅化（Raster Thread））。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  if (child.isRepaintBoundary) &#123;</span><br><span class="line">    // 创建独立 Layer</span><br><span class="line">    stopRecordingIfNeeded();</span><br><span class="line">    child._layer = OffsetLayer();</span><br><span class="line">    appendLayer(child._layer);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    child._paintWithContext(this, offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5. GPU 渲染与屏幕刷新</strong></p><blockquote><p><strong>垂直同步（VSync）：</strong><br>由系统定时触发的信号，控制帧率（如 60Hz → 16.6ms&#x2F;帧）。<br>Flutter 引擎在 VSync 信号到来时，提交光栅化后的帧数据到 GPU。</p></blockquote><blockquote><p><strong>屏幕显示：</strong><br>GPU 将帧数据写入帧缓冲区（Frame Buffer），屏幕硬件按刷新率读取并显示。</p></blockquote><h2 id="5-Widget-优化"><a href="#5-Widget-优化" class="headerlink" title="5.Widget 优化"></a>5.Widget 优化</h2><p><code>高性能渲染 = 最小化 Widget Diff + 高效布局/绘制 + GPU 线程优化</code></p><blockquote><p>Flutter 优化的本质是 减少无效计算 和 降低 GPU 负载<br>一般围绕四个方向： 1.最小化 Widget 树 Diff 范围 2.减少布局（Layout）和绘制（Paint）计算 3.优化 GPU 合成与光栅化（Rasterization） 4.高效管理状态与资源</p></blockquote><blockquote><p><strong>性能分析工具</strong><br>Flutter DevTools：<br>Performance 面板：分析 UI&#x2F;Raster 线程的帧耗时。<br>Layer 查看器：检测 Layer 合成是否合理。<br>debugProfileBuildsEnabled：追踪 Widget 构建耗时<br>调试标记：<br>debugPrintMarkNeedsLayoutStacks：打印触发布局的堆栈信息。<br>debugPaintLayerBordersEnabled：可视化 Layer 边界。</p></blockquote><p><strong>1.Widget 树 Diff 优化</strong></p><blockquote><p><strong>Diff 算法机制：</strong> 当父组件更新时，Flutter 递归对比新旧 Widget 树，判断是否需要更新 Element 和 RenderObject。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static bool canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">  return oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">      &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>复用条件：</strong> runtimeType 和 key 相同 → 复用 Element，仅更新配置。<br><strong>替换条件：</strong> 类型或 Key 不同 → 销毁旧 Element，创建新 Element。</p></blockquote><p><strong>优化策略：</strong><br><strong>1.使用 const 构造函数：</strong> const Widget 在多次重建中引用同一内存地址，Widget.canUpdate 直接返回 true，跳过 Diff 计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const MyWidget(text: &#x27;Hello&#x27;); // ✅ 优化</span><br><span class="line">MyWidget(text: &#x27;Hello&#x27;);      // ❌ 非 const</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.合理使用 Key：</strong> ValueKey：在列表项中标识唯一性，避免错误复用导致状态混乱。<br>GlobalKey：跨组件访问状态（谨慎使用，破坏局部性）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">  itemBuilder: (_, index) =&gt; ItemWidget(</span><br><span class="line">    key: ValueKey(items[index].id), // 唯一标识</span><br><span class="line">    data: items[index],</span><br><span class="line">  ),</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.拆分细粒度 Widget：</strong> 将频繁变化的部分拆分为独立 Widget，缩小 setState 触发的 Diff 范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 父组件（仅传递静态数据）</span><br><span class="line">class ParentWidget extends StatelessWidget &#123;</span><br><span class="line">  const ParentWidget(&#123;super.key&#125;);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Column(</span><br><span class="line">      children: [</span><br><span class="line">        const StaticHeader(), // 静态部分</span><br><span class="line">        DynamicContent(data: _data), // 动态部分</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.布局（Layout）阶段优化</strong></p><blockquote><p><strong>布局计算机制：</strong> 当某个 RenderObject 的尺寸变化不影响父节点布局时，可标记为布局边界，阻断布局计算向上传播。通过 RenderObject.isRepaintBoundary &#x3D; true 设置（布局边界（Relayout Boundary））</p></blockquote><blockquote><p>父节点传递 约束（Constraints） 给子节点<br>子节点根据约束计算自身尺寸，并递归布局子节点(布局过程)</p></blockquote><p><strong>优化策略</strong></p><blockquote><p><strong>1.避免过度嵌套：</strong> 多层 Row&#x2F;Column 会导致布局计算复杂度呈指数增长。<br>我们可以使用 Flex、Wrap 或自定义布局逻辑替代嵌套。</p></blockquote><blockquote><p><strong>2.预计算尺寸：</strong> 通过固定尺寸（SizedBox）或 LayoutBuilder 提前确定布局约束，减少计算量。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SizedBox(</span><br><span class="line">  width: 100,</span><br><span class="line">  height: 50,</span><br><span class="line">  child: Text(&#x27;Fixed Size&#x27;),</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>3.使用 IntrinsicWidth&#x2F;IntrinsicHeight 的替代方案：</strong> IntrinsicWidth 会触发多次子节点布局计算，性能低下。<br>我们可以手动计算子节点最大宽度，使用 ConstrainedBox 限制尺寸。</p></blockquote><p><strong>3.绘制（Paint）阶段优化</strong></p><blockquote><p><strong>绘制机制：</strong> 当 RenderObject 的视觉属性（如颜色、位置）变化时，调用 markNeedsPaint() 标记需要重绘。</p></blockquote><blockquote><p><strong>合成层（Layer）：</strong> 每个 RenderObject 的绘制结果被组织为 Layer 树，最终由 GPU 光栅化。（PictureLayer（矢量绘制）、TextureLayer（图像）、TransformLayer（变换））。</p></blockquote><p><strong>优化策略</strong></p><blockquote><p><strong>1.使用 RepaintBoundary：</strong> 将独立变化的 UI 部分包裹 RepaintBoundary，生成独立 Layer，减少重绘区域。<br>通过 RenderObject.isRepaintBoundary &#x3D; true 标记。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RepaintBoundary(</span><br><span class="line">  child: MyAnimatedWidget(), // 独立重绘区域</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>2.避免高开销绘制操作：</strong> 使用 AnimatedOpacity 或直接设置颜色透明度（Color.withOpacity）替代 Opacity 。<br>优先使用 ClipRect 或 ClipRRect，减少路径裁剪的计算量。</p></blockquote><blockquote><p><strong>3.自定义绘制优化：</strong> 在 CustomPainter 中精确控制重绘条件。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyPainter extends CustomPainter &#123;</span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(MyPainter old) &#123;</span><br><span class="line">    return old.color != color; // 仅颜色变化时重绘</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.GPU 合成与光栅化优化</strong></p><blockquote><p><strong>1.光栅化机制：</strong> 通过上面的合成与光栅化可知道：光栅化运行在独立的 Raster Thread，与 UI Thread 并行。<br>Flutter 自动复用未变化的 Layer 对应的 GPU 纹理，减少数据传输。（纹理（Texture）复用）</p></blockquote><p><strong>优化策略</strong></p><blockquote><p><strong>1.减少 Layer 数量：</strong> 过多的 Layer 会增加 GPU 合成开销，我们需要尽可能的合并相邻的 PictureLayer，避免不必要的 Opacity 或 Transform 嵌套。</p></blockquote><blockquote><p><strong>2.使用硬件加速操作：</strong> 利用 GPU 的矩阵变换硬件加速（Transform 替代手动矩阵计算）。<br>对重复使用的图片提前解码（precacheImage） （Image 预加载）。</p></blockquote><blockquote><p><strong>3.启用 Impeller 引擎：</strong> Flutter 3.0+ 引入的 Impeller 引擎针对 GPU 负载优化，减少光栅化抖动。</p></blockquote><p><strong>5.状态管理与资源优化</strong></p><blockquote><p><strong>1.状态管理：</strong><br>局部状态：使用 StatefulWidget 管理，确保 dispose() 释放资源。<br>全局状态：采用 Provider、Riverpod 或 Bloc，避免状态穿透和冗余重建。</p></blockquote><blockquote><p><strong>2.资源释放：</strong><br>必须释放动画控制器（AnimationController.dispose()）、Stream 订阅（Subscription.cancel()）等资源。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void dispose() &#123;</span><br><span class="line">  _controller.dispose();</span><br><span class="line">  _streamSubscription.cancel();</span><br><span class="line">  super.dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/img_convert/58ae194fbfc28292a73f2130d949f78a.webp?x-oss-process=image/format,png" alt="2025-05-23 14.45.52.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Widget-介绍&quot;&gt;&lt;a href=&quot;#1-Widget-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.Widget 介绍&quot;&gt;&lt;/a&gt;1.Widget 介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Everything is a widge</summary>
      
    
    
    
    <category term="Flutter" scheme="https://kindyourself.github.io/categories/Flutter/"/>
    
    
    <category term="“Flutter”" scheme="https://kindyourself.github.io/tags/%E2%80%9CFlutter%E2%80%9D/"/>
    
    <category term="“Widget”" scheme="https://kindyourself.github.io/tags/%E2%80%9CWidget%E2%80%9D/"/>
    
  </entry>
  
  <entry>
    <title>Flutter遇到的问题</title>
    <link href="https://kindyourself.github.io/2025/05/23/flutter-error/"/>
    <id>https://kindyourself.github.io/2025/05/23/flutter-error/</id>
    <published>2025-05-23T07:17:44.000Z</published>
    <updated>2025-06-09T08:25:33.473Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>1.Flutter In ios 14+,debug mode Flutter apps can only be launched from Flutter tooling。<br>原因：Debug模式下，Flutter也实现了热重载，默认编译方式为JIT而iOS 14+系统对这种编译模式做了限制，导致无法启动。</strong></p></blockquote><p>解决办法如下：用 [Xcode] 打开Flutter里面Runner工程项目，在 Build Settings 的最下方找到 User-Defined，点击 + 按钮，添加一个键为 FLUTTER_BUILD_MODE ，debug设置profile模式，release设置release 模式：<img src="https://i-blog.csdnimg.cn/img_convert/7f789a7b66202aa3d5d577d4ff7a4b51.webp?x-oss-process=image/format,png" alt="截屏2024-03-14 11.27.00.png">{target&#x3D;”_blank”}</p><blockquote><p><strong>2.将 flutter 模块 嵌入iOS工程中，编译时报错：Failed to package 。。。。flutter代码路径。。。。。Command PhaseScriptExecution failed with a nonzero exit code</strong><br><img src="https://i-blog.csdnimg.cn/img_convert/ad21f4b3e2a82eb701e1e9363f00d885.webp?x-oss-process=image/format,png" alt="截屏2024-03-14 11.28.18.png">{target&#x3D;”_blank”}</p></blockquote><p>解决办法如下：<br><strong>1.确保flutter项目代码中没有错误</strong><br><strong>2.重新构建项目：</strong><br><strong>flutter clean</strong><br><strong>2.flutter pub get（获取远程库,确定当前应用所依赖的包，并将它们保存到中央系统缓存（central system cache）中）</strong><br><strong>3.flutter run</strong></p><blockquote><p><strong>3.升级flutter：flutter upgrade –force 报错</strong><br><img src="https://i-blog.csdnimg.cn/img_convert/ed59f544c4becaac4c167e3128af66ca.webp?x-oss-process=image/format,png" alt="截屏2024-09-12 15.23.05.png">{target&#x3D;”_blank”}</p></blockquote><p>Flutter Channel版本选择<br>Flutter提供了Stable、Beta、Dev和Master四种版本，每种版本都有其特定的用途和稳定性：<br>Stable：最稳定的版本，推荐用于生产环境。<br>Beta：相对较稳定，但仍可能存在一些已知问题。<br>Dev：经过Google测试后的最新版本，包含新功能和改进。<br>Master：最新的代码主分支，更新速度非常快，几乎每天都有提交，新功能多但可能不稳定。<br>开发Flutter项目时，一般推荐使用Stable版本，以确保项目的稳定性和可靠性。如需使用某些尚未在Stable版本中支持的功能，可以考虑使用Beta或Dev版本。Master版本则更适合于那些希望尝试最新功能并愿意承受潜在不稳定性的开发者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.Flutter In ios 14+,debug mode Flutter apps can only be launched from Flutter tooling。&lt;br&gt;原因：Debug模式下，Flutter也实现了热重</summary>
      
    
    
    
    <category term="Flutter" scheme="https://kindyourself.github.io/categories/Flutter/"/>
    
    
    <category term="“Flutter”" scheme="https://kindyourself.github.io/tags/%E2%80%9CFlutter%E2%80%9D/"/>
    
    <category term="“Error”" scheme="https://kindyourself.github.io/tags/%E2%80%9CError%E2%80%9D/"/>
    
  </entry>
  
</feed>
