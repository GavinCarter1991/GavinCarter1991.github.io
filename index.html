<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="技术,编程,开发,Hexo" />
       
      <meta name="description" content="个人技术博客，分享编程、开发经验和生活感悟" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Gavin&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
      <!-- Font Awesome 6 -->
<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer" />
    <link rel="alternate" href="/atom.xml" title="Gavin's Blog" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Gavin&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Widget进阶"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/06/07/Widget%E8%BF%9B%E9%98%B6/"
    >Widget进阶</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/06/07/Widget%E8%BF%9B%E9%98%B6/" class="article-date">
  <time datetime="2025-06-07T12:17:56.000Z" itemprop="datePublished">2025-06-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1-Widget-介绍1"><a href="#1-Widget-介绍1" class="headerlink" title="1.Widget 介绍1"></a>1.Widget 介绍1</h2><blockquote>
<p>Everything is a widget 这是你学习flutter会听到的最多的一句话。因为在Flutter中几乎所有的对象都是一个 widget，在flutter中UI的构建和事件的处理基本都是通过widget的组合及嵌套来完成的。在iOS中我们经常提及的“组件”、“控件”在flutter中就是widget，当然widget的范围比之更加广泛。如：手势检测GestureDetector、主题Theme和动画容器AnimatedContainer等也是widget。</p>
</blockquote>
<p><strong>Flutter默认支持的两种设计风格：</strong></p>
<blockquote>
<p><strong>1.Material components Design：</strong> 谷歌（android）的UI风格，主要为 Android 设计，但也支持跨平台使用。</p>
</blockquote>
<blockquote>
<p><strong>2.Cupertino Design：</strong> 苹果（iOS）的UI风格，模仿苹果原生 UIKit 风格。高度还原 iOS 原生体验，适合需要与苹果生态一致的应用。</p>
</blockquote>
<h2 id="2-Widget-分类"><a href="#2-Widget-分类" class="headerlink" title="2.Widget 分类"></a>2.Widget 分类</h2><p><em><strong>1.按状态管理</strong></em></p>
<h6 id="一、StatelessWidget："><a href="#一、StatelessWidget：" class="headerlink" title="一、StatelessWidget："></a>一、StatelessWidget：</h6><p>无状态组件，通过 build 方法返回静态 UI。不可变，属性（final）在创建后无法修改，适用于不需要内部状态变化的场景（如文本显示、图标），不依赖用户交互或数据变化的 UI 部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class IconTextButton extends StatelessWidget &#123;</span><br><span class="line">  final String iconName;</span><br><span class="line">  final String label;</span><br><span class="line">  final VoidCallback onPressed;</span><br><span class="line"></span><br><span class="line">  const IconTextButton(&#123;</span><br><span class="line">    super.key,</span><br><span class="line">    required this.iconName,</span><br><span class="line">    required this.label,</span><br><span class="line">    required this.onPressed,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return GestureDetector(</span><br><span class="line">      onTap: onPressed,</span><br><span class="line">      child: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Image.asset(</span><br><span class="line">            &quot;assets/images/$iconName.png&quot;,</span><br><span class="line">            width: 40,</span><br><span class="line">            height: 40,</span><br><span class="line">          ),</span><br><span class="line">          const SizedBox(</span><br><span class="line">            height: 10,</span><br><span class="line">          ), // 图标</span><br><span class="line">          Text(</span><br><span class="line">            label,</span><br><span class="line">            style: const TextStyle(color: ColorConstant.color33, fontSize: 10),</span><br><span class="line">          ), // 文字</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="二、StatefulWidget："><a href="#二、StatefulWidget：" class="headerlink" title="二、StatefulWidget："></a>二、StatefulWidget：</h6><p>有状态组件，通过 State 对象管理动态数据。当状态变化时调用 setState 触发 UI 更新，需要用户交互（如按钮点击、表单输入）和依赖实时数据变化（如计数器、动态列表）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 上下滚动的消息轮播</span><br><span class="line">class MarqueeWidget extends StatefulWidget &#123;</span><br><span class="line">  /// 子视图数量</span><br><span class="line">  final int count;</span><br><span class="line"></span><br><span class="line">  ///子视图构建器</span><br><span class="line">  final IndexedWidgetBuilder itemBuilder;</span><br><span class="line"></span><br><span class="line">  ///轮播的时间间隔</span><br><span class="line">  final int loopSeconds;</span><br><span class="line"></span><br><span class="line">  const MarqueeWidget(&#123;</span><br><span class="line">    super.key,</span><br><span class="line">    required this.count,</span><br><span class="line">    required this.itemBuilder,</span><br><span class="line">    this.loopSeconds = 5,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MarqueeWidgetState createState() =&gt; _MarqueeWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MarqueeWidgetState extends State&lt;MarqueeWidget&gt; &#123;</span><br><span class="line">  late PageController _controller;</span><br><span class="line">  late Timer _timer;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    _controller = PageController();</span><br><span class="line">    _timer = Timer.periodic(Duration(seconds: widget.loopSeconds), (timer) &#123;</span><br><span class="line">      if (_controller.page != null) &#123;</span><br><span class="line">        // 如果当前位于最后一页，则直接跳转到第一页，两者内容相同，跳转时视觉上无感知</span><br><span class="line">        if (_controller.page!.round() &gt;= widget.count) &#123;</span><br><span class="line">          _controller.jumpToPage(0);</span><br><span class="line">        &#125;</span><br><span class="line">        _controller.nextPage(</span><br><span class="line">            duration: const Duration(seconds: 1), curve: Curves.linear);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return PageView.builder(</span><br><span class="line">      scrollDirection: Axis.vertical,</span><br><span class="line">      controller: _controller,</span><br><span class="line">      itemBuilder: (buildContext, index) &#123;</span><br><span class="line">        if (index &lt; widget.count) &#123;</span><br><span class="line">          return widget.itemBuilder(buildContext, index);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return widget.itemBuilder(buildContext, 0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      itemCount: widget.count + 1,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    super.dispose();</span><br><span class="line">    _controller.dispose();</span><br><span class="line">    _timer.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>2.按功能分类</strong></em></p>
<blockquote>
<p><strong>1.布局类 Widget：</strong> 控制子 Widget 的排列方式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Row/Column：水平/垂直排列子项（基于 Flexbox）。</span><br><span class="line">Stack：子 Widget 堆叠（类似 CSS 的绝对定位）。</span><br><span class="line">Expanded/Flexible：在 Row 或 Column 中分配剩余空间。</span><br><span class="line">Container：结合布局、装饰、边距等功能</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>2.基础组件 Widget：</strong> 构成 UI 的基本元素。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Text：显示文本。</span><br><span class="line">Image：加载本地或网络图片。</span><br><span class="line">Icon：显示图标（需引入 cupertino_icons 或自定义图标库）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>3.滚动类 Widget：</strong> 处理内容超出屏幕时的滚动行为。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">ListView：垂直/水平滚动列表。</span><br><span class="line">GridView：网格布局滚动视图。</span><br><span class="line">SingleChildScrollView：包裹单个可滚动子组件。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>4.交互类 Widget：</strong> 响应用户输入事件。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">ElevatedButton/TextButton：按钮交互。</span><br><span class="line">TextField：文本输入框。</span><br><span class="line">Checkbox/Switch：选择控件。</span><br><span class="line">GestureDetector：自定义手势检测（点击、长按、拖动）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>5.平台风格类 Widget：</strong> 适配不同操作系统的视觉风格。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Material Design：MaterialApp、AppBar、FloatingActionButton。</span><br><span class="line">Cupertino（iOS 风格）：CupertinoApp、CupertinoNavigationBar、CupertinoPicker。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>6.动画类 Widget：</strong> 实现动态视觉效果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">AnimatedContainer：自动过渡的容器（大小、颜色等属性变化）。</span><br><span class="line">Hero：页面切换共享元素的过渡动画。</span><br><span class="line">AnimatedBuilder：自定义复杂动画。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>7. 导航与路由类 Widget：</strong> 管理页面跳转和导航结构。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Navigator：管理页面堆栈（push/pop）。</span><br><span class="line">PageView：实现滑动切换页面。</span><br><span class="line">BottomNavigationBar：底部导航栏。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过简单 Widget 组合实现复杂 UI（例如用 Row + Expanded 替代自定义布局）(优先组合而非继承)<br>局部状态使用 StatefulWidget<br>全局状态使用状态管理工具（如 Provider、Riverpod）<br>对频繁更新的部分使用 const 构造函数<br>长列表使用 ListView.builder 懒加载</p>
</blockquote>
<h2 id="3-Widget-生命周期"><a href="#3-Widget-生命周期" class="headerlink" title="3.Widget 生命周期"></a>3.Widget 生命周期</h2><p><strong>StatelessWidget 的生命周期</strong></p>
<blockquote>
<p>StatelessWidget 仅有一个 build() 方法，无状态管理逻辑，其生命周期完全由父组件控制。</p>
</blockquote>
<p><strong>StatefulWidget主要生命周期方法</strong></p>
<blockquote>
<p>创建阶段<br>createState()</p>
</blockquote>
<blockquote>
<p>初始化阶段<br>initState()<br>didChangeDependencies()</p>
</blockquote>
<blockquote>
<p>更新阶段<br>didUpdateWidget(oldWidget)<br>build()</p>
</blockquote>
<blockquote>
<p>销毁阶段<br>deactivate()<br>dispose()</p>
</blockquote>
<p><img src="https://i-blog.csdnimg.cn/img_convert/a33469c55f94b5278f698d8605d8e0cc.webp?x-oss-process=image/format,png" alt="2025-05-22 18.38.22.png"><br><strong>1.createState()</strong><br>当 StatefulWidget 被插入 Widget 树时调用，而且只执行一次。</p>
<blockquote>
<p>主要用于创建与之关联的 State 对象（每个 Widget 对应一个 State 实例）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyWidget extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _MyWidgetState createState() =&gt; _MyWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2.initState()</strong><br>在State 对象创建后，首次调用 build() 之前触发该方法，而且只执行一次。</p>
<blockquote>
<p>主要用于初始化依赖数据（如订阅事件、加载本地配置）和 创建动画控制器（AnimationController）等需与 dispose() 配对的资源。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  super.initState();</span><br><span class="line">  _controller = AnimationController(vsync: this);</span><br><span class="line">  _fetchData(); // 初始化数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是：<br><code>必须调用 super.initState()。</code><br><code>在这里 View 并没有渲染，只是 StatefulWidget 被加载到渲染树里了。</code><br><code>避免在此处触发 setState（可能导致渲染未完成）。</code><br><code>StatefulWidget的 mount 的值变为了true（调用dispose()才会变为 false）。</code></p>
<p><strong>3.didChangeDependencies()</strong><br>initState() 后立即调用didChangeDependencies()。<br>当 State 依赖的 InheritedWidget 发生变化时（如主题、本地化）也会调用didChangeDependencies()。</p>
<blockquote>
<p>主要用于处理依赖变化后的逻辑（如重新请求网络数据）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void didChangeDependencies() &#123;</span><br><span class="line">  super.didChangeDependencies();</span><br><span class="line">  if (Provider.of&lt;Data&gt;(context).hasChanged) &#123;</span><br><span class="line">    _updateData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>4. didUpdateWidget(oldWidget)</strong><br>在父组件重建时，若新旧 Widget 的 runtimeType 和 key 相同触发didUpdateWidget（didUpdateWidget我们一般不会用到）。</p>
<blockquote>
<p>主要是：<br>对比新旧 Widget 的配置（如属性变化）。<br>根据变化调整状态（如重置动画、更新监听）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void didUpdateWidget(MyWidget oldWidget) &#123;</span><br><span class="line">  super.didUpdateWidget(oldWidget);</span><br><span class="line">  if (oldWidget.color != widget.color) &#123;</span><br><span class="line">    _updateColor(); // 颜色变化时执行逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>5. build()</strong><br>初始化后、依赖变化后、setState() 调用后调用build()。<br>父组件或祖先组件触发重建时调用build()。</p>
<blockquote>
<p>主要是根据当前状态构建 UI（不要在这里做除了创建 Widget 之外的操作）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Container(</span><br><span class="line">    color: widget.color,</span><br><span class="line">    child: Text(&#x27;Count: $_count&#x27;),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是：<br><code>必须返回一个 Widget</code><br><code>避免在此处修改状态或执行耗时操作</code></p>
<p><strong>6. deactivate()</strong><br>当 State 从树中暂时移除（如页面切换、组件被移除）触发deactivate()。</p>
<blockquote>
<p>清理临时资源或保存临时状态.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">需要注意的是：</span><br><span class="line">`可能被重新插入树中（如页面返回时），需与 dispose() 区分`</span><br><span class="line"></span><br><span class="line">**7. dispose()**</span><br><span class="line">State 被永久移除时调用dispose()。</span><br><span class="line">&gt;释放资源（如取消网络请求、销毁动画控制器）</span><br></pre></td></tr></table></figure>
<p>@override<br>void dispose() {<br>  _controller.dispose(); &#x2F;&#x2F; 销毁动画控制器<br>  _subscription.cancel(); &#x2F;&#x2F; 取消事件订阅<br>  super.dispose();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">需要注意的是：</span><br><span class="line">`如果在 dispose() 中未释放资源（如动画控制器、Stream 订阅）可能造成内存泄漏`</span><br><span class="line">`如果在 dispose() 后调用 setState 会导致异常`</span><br><span class="line"></span><br><span class="line">## 4.Widget 的渲染</span><br><span class="line">**渲染流程：**</span><br><span class="line">Flutter 的渲染系统基于三棵核心树结构，通过高度优化的管线（Pipeline）实现高效的 UI 更新。</span><br><span class="line">&gt;**Widget 重建 → Diff 新旧 Widget 树 → 更新 Element 树 → 更新 RenderObject 树 → 触发 Layer 合成 → 屏幕刷新**</span><br><span class="line"></span><br><span class="line">**1.Widget 树的构建：**</span><br><span class="line">&gt;描述 UI 的不可变配置，由开发者创建，频繁重建，需轻量化。</span><br><span class="line">开发者编写的 Widget 代码被转化为嵌套的 Widget 树（应用的入口是根Widget，一般是MaterialApp或CupertinoApp。根Widget会递归地构建其子Widget，形成一棵树。）。</span><br><span class="line">具有不可变性，每次重建生成全新的 Widget 树，但通过 Diff 算法可以优化实际更新范围。</span><br><span class="line"></span><br><span class="line">**2. Element 树的 Diff 与更新**</span><br><span class="line">&gt;根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 Element 类。</span><br><span class="line">Element 是 Widget 的实例化对象，负责管理 状态（State） 和 子节点引用。</span><br><span class="line">每个Widget都会有一个对应的Element对象，用于管理其生命周期。</span><br><span class="line"></span><br><span class="line">&gt;Diff 算法：Flutter 对比新旧 Widget 树，仅更新变化的 Element 和 RenderObject，类似 React 的虚拟 DOM。</span><br><span class="line">&gt;当 Widget 树重建时，Flutter 通过 Diff 算法 对比新旧 Widget 树，决定 Element 树的更新策略</span><br><span class="line">Reuse：若新旧 Widget 的 runtimeType 和 key 相同，复用现有 Element。</span><br><span class="line">Update：更新 Element 的配置（调用 Element.update(newWidget)）。</span><br><span class="line">Replace：类型或 Key 不同时，销毁旧 Element，创建新 Element。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 旧 Widget 树<br>Container(color: Colors.red)</p>
<p>&#x2F;&#x2F; 新 Widget 树<br>Container(color: Colors.blue)</p>
<p>&#x2F;&#x2F; Diff 结果：Container 类型相同且无 Key → 复用 Element，更新 RenderObject 颜色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; Element 更新逻辑<br>Element.updateChild()</p>
<p>Element updateChild(Element child, Widget newWidget, dynamic newSlot) {<br>  if (newWidget &#x3D;&#x3D; null) {<br>    &#x2F;&#x2F; 移除子节点<br>    return null;<br>  }<br>  if (child !&#x3D; null) {<br>    if (child.widget &#x3D;&#x3D; newWidget) {<br>      &#x2F;&#x2F; Widget 未变化 → 复用 Element<br>      return child;<br>    }<br>    if (Widget.canUpdate(child.widget, newWidget)) {<br>      &#x2F;&#x2F; 更新 Element 配置<br>      child.update(newWidget);<br>      return child;<br>    }<br>    &#x2F;&#x2F; 销毁旧 Element，创建新 Element<br>    deactivateChild(child);<br>  }<br>  return inflateWidget(newWidget, newSlot);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**3. RenderObject 树的更新**</span><br><span class="line"></span><br><span class="line">更新 RenderObject 树，计算布局和生成绘制指令。</span><br><span class="line">运行在 UI Thread。</span><br><span class="line"></span><br><span class="line">&gt;根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自RenderObject 类。</span><br><span class="line">每个 Element 对应一个 RenderObject（通过 Element.createRenderObject() 创建）。</span><br><span class="line"></span><br><span class="line">&gt;根据父 RenderObject 传递的 约束（Constraints），计算自身尺寸和位置。</span><br><span class="line">递归调用子节点的 layout() 方法（深度优先遍历）。</span><br><span class="line"></span><br><span class="line">**布局（Layout）核心方法：**</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; RenderObject 布局流程<br>RenderObject.layout()</p>
<p>void layout(Constraints constraints, { bool parentUsesSize &#x3D; false }) {<br>  _constraints &#x3D; constraints;<br>  if (_relayoutBoundary !&#x3D; this) {<br>    markNeedsLayout();<br>    return;<br>  }<br>  performLayout();  &#x2F;&#x2F; 1. 计算自身尺寸（调用 performLayout） 由子类实现具体布局逻辑<br>  _needsLayout &#x3D; false;<br>  markNeedsPaint(); &#x2F;&#x2F; 标记需要重绘<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;生成绘制指令（如形状、颜色、文本），写入 Layer（合成层）。</span><br><span class="line"></span><br><span class="line">**绘制（Paint）核心方法:**</span><br></pre></td></tr></table></figure>
<p>void paint(PaintingContext context, Offset offset) {<br>  &#x2F;&#x2F; 绘制逻辑，如画矩形<br>  context.canvas.drawRect(rect, paint);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**4. 合成与光栅化（Composition &amp; Rasterization）**</span><br><span class="line"></span><br><span class="line">生成 Layer 树并光栅化。</span><br><span class="line">运行在 Raster Thread（与 UI Thread 并行）</span><br><span class="line"></span><br><span class="line">&gt;根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 Layer 类。</span><br><span class="line">RenderObject 的绘制结果被组织为 Layer 树，每个 Layer 对应一个 GPU 纹理（Texture）。自此Layer 树生成。</span><br><span class="line">类型包括：PictureLayer（矢量绘制）、TextureLayer（图像纹理）、TransformLayer（变换效果）等。</span><br><span class="line"></span><br><span class="line">&gt;将 Layer 树中的绘制指令转换为 GPU 可识别的位图数据。</span><br><span class="line">通过 Skia 图形库（或 Impeller）完成，最终提交给 GPU 渲染。（完成光栅化（Raster Thread））。</span><br></pre></td></tr></table></figure>
<p>void paintChild(RenderObject child, Offset offset) {<br>  if (child.isRepaintBoundary) {<br>    &#x2F;&#x2F; 创建独立 Layer<br>    stopRecordingIfNeeded();<br>    child._layer &#x3D; OffsetLayer();<br>    appendLayer(child._layer);<br>  } else {<br>    child._paintWithContext(this, offset);<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**5. GPU 渲染与屏幕刷新**</span><br><span class="line">  </span><br><span class="line">&gt;**垂直同步（VSync）：**</span><br><span class="line">由系统定时触发的信号，控制帧率（如 60Hz → 16.6ms/帧）。</span><br><span class="line">Flutter 引擎在 VSync 信号到来时，提交光栅化后的帧数据到 GPU。</span><br><span class="line"></span><br><span class="line">&gt;**屏幕显示：**</span><br><span class="line">GPU 将帧数据写入帧缓冲区（Frame Buffer），屏幕硬件按刷新率读取并显示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5.Widget 优化</span><br><span class="line"></span><br><span class="line">`高性能渲染 = 最小化 Widget Diff + 高效布局/绘制 + GPU 线程优化`</span><br><span class="line"></span><br><span class="line">&gt;Flutter 优化的本质是 减少无效计算 和 降低 GPU 负载</span><br><span class="line">一般围绕四个方向：</span><br><span class="line">1.最小化 Widget 树 Diff 范围</span><br><span class="line">2.减少布局（Layout）和绘制（Paint）计算</span><br><span class="line">3.优化 GPU 合成与光栅化（Rasterization）</span><br><span class="line">4.高效管理状态与资源</span><br><span class="line"></span><br><span class="line">&gt;**性能分析工具**</span><br><span class="line">Flutter DevTools：</span><br><span class="line">Performance 面板：分析 UI/Raster 线程的帧耗时。</span><br><span class="line">Layer 查看器：检测 Layer 合成是否合理。</span><br><span class="line">debugProfileBuildsEnabled：追踪 Widget 构建耗时</span><br><span class="line">调试标记：</span><br><span class="line">debugPrintMarkNeedsLayoutStacks：打印触发布局的堆栈信息。</span><br><span class="line">debugPaintLayerBordersEnabled：可视化 Layer 边界。</span><br><span class="line"></span><br><span class="line">**1.Widget 树 Diff 优化**</span><br><span class="line"></span><br><span class="line">&gt;**Diff 算法机制：** 当父组件更新时，Flutter 递归对比新旧 Widget 树，判断是否需要更新 Element 和 RenderObject。</span><br></pre></td></tr></table></figure>
<p>static bool canUpdate(Widget oldWidget, Widget newWidget) {<br>  return oldWidget.runtimeType &#x3D;&#x3D; newWidget.runtimeType<br>      &amp;&amp; oldWidget.key &#x3D;&#x3D; newWidget.key;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;**复用条件：** runtimeType 和 key 相同 → 复用 Element，仅更新配置。</span><br><span class="line">**替换条件：** 类型或 Key 不同 → 销毁旧 Element，创建新 Element。</span><br><span class="line"></span><br><span class="line">**优化策略：**</span><br><span class="line">**1.使用 const 构造函数：** const Widget 在多次重建中引用同一内存地址，Widget.canUpdate 直接返回 true，跳过 Diff 计算。</span><br></pre></td></tr></table></figure>
<p>const MyWidget(text: ‘Hello’); &#x2F;&#x2F; ✅ 优化<br>MyWidget(text: ‘Hello’);      &#x2F;&#x2F; ❌ 非 const</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**2.合理使用 Key：** ValueKey：在列表项中标识唯一性，避免错误复用导致状态混乱。</span><br><span class="line">GlobalKey：跨组件访问状态（谨慎使用，破坏局部性）。</span><br></pre></td></tr></table></figure>
<p>ListView.builder(<br>  itemBuilder: (_, index) &#x3D;&gt; ItemWidget(<br>    key: ValueKey(items[index].id), &#x2F;&#x2F; 唯一标识<br>    data: items[index],<br>  ),<br>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**3.拆分细粒度 Widget：** 将频繁变化的部分拆分为独立 Widget，缩小 setState 触发的 Diff 范围。</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 父组件（仅传递静态数据）<br>class ParentWidget extends StatelessWidget {<br>  const ParentWidget({super.key});<br>  @override<br>  Widget build(BuildContext context) {<br>    return Column(<br>      children: [<br>        const StaticHeader(), &#x2F;&#x2F; 静态部分<br>        DynamicContent(data: _data), &#x2F;&#x2F; 动态部分<br>      ],<br>    );<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**2.布局（Layout）阶段优化**</span><br><span class="line"></span><br><span class="line">&gt;**布局计算机制：** 当某个 RenderObject 的尺寸变化不影响父节点布局时，可标记为布局边界，阻断布局计算向上传播。通过 RenderObject.isRepaintBoundary = true 设置（布局边界（Relayout Boundary））</span><br><span class="line"></span><br><span class="line">&gt;父节点传递 约束（Constraints） 给子节点</span><br><span class="line">子节点根据约束计算自身尺寸，并递归布局子节点(布局过程)</span><br><span class="line"></span><br><span class="line">**优化策略**</span><br><span class="line">&gt;**1.避免过度嵌套：** 多层 Row/Column 会导致布局计算复杂度呈指数增长。</span><br><span class="line">我们可以使用 Flex、Wrap 或自定义布局逻辑替代嵌套。</span><br><span class="line"></span><br><span class="line">&gt;**2.预计算尺寸：** 通过固定尺寸（SizedBox）或 LayoutBuilder 提前确定布局约束，减少计算量。</span><br></pre></td></tr></table></figure>
<p>SizedBox(<br>  width: 100,<br>  height: 50,<br>  child: Text(‘Fixed Size’),<br>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;**3.使用 IntrinsicWidth/IntrinsicHeight 的替代方案：**     IntrinsicWidth 会触发多次子节点布局计算，性能低下。</span><br><span class="line">我们可以手动计算子节点最大宽度，使用 ConstrainedBox 限制尺寸。</span><br><span class="line"></span><br><span class="line">**3.绘制（Paint）阶段优化**</span><br><span class="line"></span><br><span class="line">&gt;**绘制机制：** 当 RenderObject 的视觉属性（如颜色、位置）变化时，调用 markNeedsPaint() 标记需要重绘。</span><br><span class="line"></span><br><span class="line">&gt;**合成层（Layer）：** 每个 RenderObject 的绘制结果被组织为 Layer 树，最终由 GPU 光栅化。（PictureLayer（矢量绘制）、TextureLayer（图像）、TransformLayer（变换））。</span><br><span class="line"></span><br><span class="line">**优化策略**</span><br><span class="line">&gt;**1.使用 RepaintBoundary：** 将独立变化的 UI 部分包裹 RepaintBoundary，生成独立 Layer，减少重绘区域。</span><br><span class="line">通过 RenderObject.isRepaintBoundary = true 标记。</span><br></pre></td></tr></table></figure>
<p>RepaintBoundary(<br>  child: MyAnimatedWidget(), &#x2F;&#x2F; 独立重绘区域<br>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;**2.避免高开销绘制操作：** 使用 AnimatedOpacity 或直接设置颜色透明度（Color.withOpacity）替代Opacity 。</span><br><span class="line">优先使用 ClipRect 或 ClipRRect，减少路径裁剪的计算量。</span><br><span class="line"></span><br><span class="line">&gt;**3.自定义绘制优化：** 在 CustomPainter 中精确控制重绘条件。</span><br></pre></td></tr></table></figure>
<p>class MyPainter extends CustomPainter {<br>  @override<br>  bool shouldRepaint(MyPainter old) {<br>    return old.color !&#x3D; color; &#x2F;&#x2F; 仅颜色变化时重绘<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**4.GPU 合成与光栅化优化**</span><br><span class="line"></span><br><span class="line">&gt;**1.光栅化机制：** 通过上面的合成与光栅化可知道：光栅化运行在独立的 Raster Thread，与 UI Thread 并行。</span><br><span class="line">Flutter 自动复用未变化的 Layer 对应的 GPU 纹理，减少数据传输。（纹理（Texture）复用）</span><br><span class="line"></span><br><span class="line">**优化策略**</span><br><span class="line"></span><br><span class="line">&gt;**1.减少 Layer 数量：** 过多的 Layer 会增加 GPU 合成开销，我们需要尽可能的合并相邻的 PictureLayer，避免不必要的 Opacity 或 Transform 嵌套。</span><br><span class="line"></span><br><span class="line">&gt;**2.使用硬件加速操作：** 利用 GPU 的矩阵变换硬件加速（Transform 替代手动矩阵计算）。</span><br><span class="line">对重复使用的图片提前解码（precacheImage） （Image 预加载）。</span><br><span class="line"></span><br><span class="line">&gt;**3.启用 Impeller 引擎：** Flutter 3.0+ 引入的 Impeller 引擎针对 GPU 负载优化，减少光栅化抖动。</span><br><span class="line"></span><br><span class="line">**5.状态管理与资源优化**</span><br><span class="line"></span><br><span class="line">&gt;**1.状态管理：**</span><br><span class="line">局部状态：使用 StatefulWidget 管理，确保 dispose() 释放资源。</span><br><span class="line">&gt;全局状态：采用 Provider、Riverpod 或 Bloc，避免状态穿透和冗余重建。</span><br><span class="line"></span><br><span class="line">&gt;**2.资源释放：**</span><br><span class="line">必须释放动画控制器（AnimationController.dispose()）、Stream 订阅（Subscription.cancel()）等资源。</span><br></pre></td></tr></table></figure>
<p>@override<br>void dispose() {<br>  _controller.dispose();<br>  _streamSubscription.cancel();<br>  super.dispose();<br>}</p>
<pre><code>![2025-05-23 14.45.52.png](https://i-blog.csdnimg.cn/img_convert/58ae194fbfc28292a73f2130d949f78a.webp?x-oss-process=image/format,png)
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E2%80%9CFlutter%E2%80%9D/" rel="tag">“Flutter”</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E2%80%9CWidget%E2%80%9D/" rel="tag">“Widget”</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/06/07/hello-world/"
    >Hello World</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/06/07/hello-world/" class="article-date">
  <time datetime="2025-06-07T11:48:26.702Z" itemprop="datePublished">2025-06-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2025
        <i class="ri-heart-fill heart_icon"></i> kindyourself@163.com
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Gavin&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.jianshu.com/u/51707eacf496">简书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>