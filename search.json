[{"title":"UISearchBar详解","url":"/2017/03/11/UISearchBar%E8%AF%A6%E8%A7%A3/","content":"\n今天公司的项目测试的差不多了，基本可以上架了，又有时间来分享一下最近遇到的一些问题了，公司的项目进行了大改版（应该是全改了，基本是一个新的项目了），老大决定用swift重写。之前一直在自学swift，终于这一次可以实战了。项目中搜索用的比较多，但是搜索框的样式与默认的差别太大了，所以只能自定义了。\n\nThe UISearchBar class implements a text field control for text-based searches. The control provides a text field for entering text, a search button, a bookmark button, and a cancel button. The UISearchBar object does not actually perform any searches. You use a delegate, an object conforming to the UISearchBarDelegate protocol, to implement the actions when text is entered and buttons are clicked.\n\n\n以上是苹果对UISearchBar的解释，可以看见UISearchBar提供了类似UITextField的输入（其实它的组成中就有UITextField，下面会讲到），右边有搜索按钮、标签按钮、关闭按钮可供选择，搜索都是在协议UISearchBarDelegate中进行。\n\n自定义外观\n\n\n\nUISearchBar的层级很是复杂主要由UISearchBarBackgroud、UISearchBarTextField、UINavigationButton组成，其中UISearchBarTextField就是输入框，主要是由——UISearchBarSearchFieldBackgroundView、UIButton（❌）、UIImageView（?）等组成，\n\n获取TextField方法：\nlet searchFiled:UITextField = self.searchBar.value(forKey: &quot;_searchField&quot;) as! UITextField\n这样就可以通过修改\tsearchFiled来修改输入样式（圆角、字体等）。\n\nUISearchBar的直接子控件是UIVIew，其上的子控件UISearchBarBackgroud的frame与UISearchBar的bounds相等，UISearchBarTextField的高度默认为28与UISearchBar左右有8像素的固定间距，上下间距为直接子控件UIView的高度 - UISearchBarTextField的默认高度28 再除以2。因此UISearchBar的输入框始终与设置的frame不一样，不便于布局，我们可以添加一个子类继承UISearchBar，可以更改其内边距。\n\nclass MySearchBar: UISearchBar &#123;        // 监听是否添加了该属性    var contentInset: UIEdgeInsets? &#123;        didSet &#123;            self.layoutSubviews()        &#125;    &#125;        override func layoutSubviews() &#123;        super.layoutSubviews()        // 便利寻找        for view in self.subviews &#123;            for subview in view.subviews &#123;                // 判定是否是UISearchBarTextField                if subview.isKind(of: UITextField.classForCoder()) &#123;                    if let textFieldContentInset = contentInset &#123;                        // 修改UISearchBarTextField的布局                        subview.frame = CGRect(x: textFieldContentInset.left, y: textFieldContentInset.top, width: self.bounds.width - textFieldContentInset.left - textFieldContentInset.right, height: self.bounds.height - textFieldContentInset.top - textFieldContentInset.bottom)                    &#125; else &#123;                        // 设置UISearchBar中UISearchBarTextField的默认边距                        let top: CGFloat = (self.bounds.height - 28.0) / 2.0                        let bottom: CGFloat = top                        let left: CGFloat = 8.0                        let right: CGFloat = left                        contentInset = UIEdgeInsets(top: top, left: left, bottom: bottom, right: right)                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n让实例化的UISearchBar继承MySearchBar，然后就可以很方便的直接控制内边距了\n\nself.searchBar.contentInset = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)\n\n\n接下来就是处理placeholder靠左，这个就比较麻烦了，查询了一大堆办法都挺麻烦的，最后找到了一个很投机的办法：先判定手机宽度，然后在placeholder右边加上空格做成靠左的假象。\n\nif SCREEN.WIDTH == 320 &#123;           self.searchBar.placeholder = &quot;搜索位置       &quot;       &#125;else if SCREEN.WIDTH == 373\\5 &#123;           self.searchBar.placeholder = &quot;搜索位置                  &quot;       &#125;else if SCREEN.WIDTH == 414 &#123;           self.searchBar.placeholder = &quot;搜索位置                                 &quot;       &#125;\n\n\n然后在storyboard中设置searchBar的BarStyle为Minimal就可以很方便的控制UISearchBar的外观了。到这里就剩一个问题了：UISearchBar上下的两根黑线了，\n\n去除方法：\nself.searchBar.setBackgroundImage(UIImage.init(), for: .any, barMetrics: .default)\n\n搜索的使用\n\n如苹果官方文档所说，与搜索相关的都是在其代理方法中完成。UISearchBar有很多的代理方法，感兴趣的可以点击进入查看\n\nUISearchBarDelegate我就介绍几个常用的：\n\n当搜索内容变化时，执行该方法,可以实时监听输入框的变化,可以实现时实搜索。\n\n- (BOOL)searchBar:(UISearchBar *)searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)textNS_AVAILABLE_IOS(3_0);                 // called before text changes\n\n\n也行你想把搜索事件放在点击搜索以后再触发，那就选用这个方法，它就是点击搜索后的代理方法\n\n- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar;\n\n结束\n当然如果你觉得这样太麻烦了，你还可以选择用UITextField来实现UISearchBar的功能，但是最终哪一个更加的麻烦还需要试一试才知道。\n\n","categories":["swift"],"tags":["“iOS”","“swift”","“UISearchBar”"]},{"title":"Base64-不重要数据的简单加密","url":"/2016/07/09/Base64-%E4%B8%8D%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%A0%E5%AF%86/","content":"导语\n 最近公司要求对服务器的token等参数进行一个简单的加密，防止恶意请求。要求加密过程自定义，于是就想到了用base64，其实这不是一个加密解密的算法，其实它就是使用64个字符来对任意数据进行编码解码的，具体底层实现原理就不讨论了，它是随着iOS7推出的。\n\n##我的实现过程（可以根据公司需求自定义）：\n\n先编码一次\n对编码结果的数据交换首位字符在编码一次\n对编码结果逆序在编码一次\n\n##示例代码\n+(NSString *)base64EncodedString:(NSString *)string &#123;Base64Encoding *base64 = [[Base64Encoding alloc] init];       // 1次    NSString *encrypt1 = [base64 base64EncodedString:string];    // 交换字符串首位次序    NSString *string1 = [base64 changeStringFirsrAndLast:encrypt1];        // 2次    NSString *encrypt2 = [base64 base64EncodedString:string1];    // 交换字符串首位次序    NSString *string2 = [base64 changeStringOrder:encrypt2];        // 3次    NSString *encrypt3 = [base64 base64EncodedString:string2];        return encrypt3;&#125;// 添加逗号- (NSString *)addSeparaedSingle:(NSString *)string &#123;    NSMutableString *mutableString = [string mutableCopy];    NSInteger cont = mutableString.length;    for (int i = 0; i &lt; cont - 1; i ++) &#123;        [mutableString insertString:@&quot;,&quot; atIndex:2 * i + 1];    &#125;    return mutableString;&#125;// 去掉逗号- (NSString *)removeSeparaedSingle:(NSString *)string &#123;   return [string stringByReplacingOccurrencesOfString:@&quot;,&quot; withString:@&quot;&quot;];&#125;// 字符串转数组- (NSMutableArray *)stringChangeArray:(NSString *)string &#123;    NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:[string componentsSeparatedByString:@&quot;,&quot;]];    return mutableArray;&#125;// 数组转字符串- (NSString *)arrayChangeString:(NSArray *)array &#123;    return [array componentsJoinedByString:@&quot;,&quot;];&#125;// 字符串交换首尾- (NSString *)changeStringFirsrAndLast:(NSString *)string &#123;    NSString *str = [self addSeparaedSingle:string];    NSMutableArray *mutableArray = [self stringChangeArray:str];    NSString *temp = mutableArray[0];    mutableArray[0] = mutableArray[mutableArray.count - 1];    mutableArray[mutableArray.count - 1] = temp;    NSString *arrayString = [self arrayChangeString:mutableArray];    return [self removeSeparaedSingle:arrayString];&#125;// 字符串逆序- (NSString *)changeStringOrder:(NSString *)string &#123;    NSString *str = [self addSeparaedSingle:string];    NSMutableArray *mutableArray = [self stringChangeArray:str];    NSArray *reversedArray = [[mutableArray reverseObjectEnumerator] allObjects];    NSString *arrayString = [self arrayChangeString:reversedArray];    return [self removeSeparaedSingle:arrayString];&#125;// 编码- (NSString *)base64EncodedString:(NSString *)string &#123;    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];    return [data base64EncodedStringWithOptions:0];&#125;\n###结束语：\n\n  这个可以根据公司的要求跟后台写的好加密的规则，解密就交给后台了，方法：initWithBase64EncodedData 采用逆向规则解密即可，当然这个是极其容易被破解的，涉及敏感数据是不可使用这个方法的。\n\n","categories":["iOS"],"tags":["“Base64”","“加密”"]},{"title":"Flutter遇到的问题","url":"/2025/05/23/flutter-error/","content":"\n1.Flutter In ios 14+,debug mode Flutter apps can only be launched from Flutter tooling。原因：Debug模式下，Flutter也实现了热重载，默认编译方式为JIT而iOS 14+系统对这种编译模式做了限制，导致无法启动。\n\n解决办法如下：用 [Xcode] 打开Flutter里面Runner工程项目，在 Build Settings 的最下方找到 User-Defined，点击 + 按钮，添加一个键为 FLUTTER_BUILD_MODE ，debug设置profile模式，release设置release 模式：{target&#x3D;”_blank”}\n\n2.将 flutter 模块 嵌入iOS工程中，编译时报错：Failed to package 。。。。flutter代码路径。。。。。Command PhaseScriptExecution failed with a nonzero exit code{target&#x3D;”_blank”}\n\n解决办法如下：1.确保flutter项目代码中没有错误2.重新构建项目：flutter clean2.flutter pub get（获取远程库,确定当前应用所依赖的包，并将它们保存到中央系统缓存（central system cache）中）3.flutter run\n\n3.升级flutter：flutter upgrade –force 报错{target&#x3D;”_blank”}\n\nFlutter Channel版本选择Flutter提供了Stable、Beta、Dev和Master四种版本，每种版本都有其特定的用途和稳定性：Stable：最稳定的版本，推荐用于生产环境。Beta：相对较稳定，但仍可能存在一些已知问题。Dev：经过Google测试后的最新版本，包含新功能和改进。Master：最新的代码主分支，更新速度非常快，几乎每天都有提交，新功能多但可能不稳定。开发Flutter项目时，一般推荐使用Stable版本，以确保项目的稳定性和可靠性。如需使用某些尚未在Stable版本中支持的功能，可以考虑使用Beta或Dev版本。Master版本则更适合于那些希望尝试最新功能并愿意承受潜在不稳定性的开发者。\n","categories":["Flutter"],"tags":["“Flutter”","“Error”"]},{"title":"gitHub hexo 个人博客","url":"/2016/07/16/gitHub-hexo-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"\n一直以来就想搭建一个自己的博客，不想其它网站那么杂乱，需要一个纯粹的记录成长之路的地方。查了很多资料，最后决定用hexo 搭建一个静态网页，托管在gitHub上。下面我就介绍一下我的搭建之路，我的搭建网页。\n\n1. gitHubgitHub 的注册及配置我就不介绍了，这个哪里都可以查到，我介绍一下注册过后远程仓库的创建。首先创建远程仓库：在后面的Respository name 里面输入：gavincarter1991.github.io 这个格式是定的（gavincarter1991 需要填写你的用户名）我没有测试过如果不填写自己用户名的后果，不过查了很多资料都推荐这样填写，有的还是不以这样的方式会报错，没有实践，我没有发言权。\n2. homebrew安装/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n\nbrew install node\n查看安装是否成功：\nnpm -v\n\nnode -v\n安装成功会显示版本号：\n3. 开始安装hexo首先进入你需要存放博客的文件夹，然后：\nnpm install hexo -g\n\n查看版本号：\nhexo version\n初始化项目：(类似于git)\nhexo init\n\n4. 开始使用创建页面：\nhexo new post &quot;My First Blog&quot;\n生成静态文件(会在当前目录下生成一个新的叫做public的文件夹)\nhexo g # 或者hexo generate\n开启本地服务 用于在本地浏览 Ctrl+C退出查看\nhexo s # 或者hexo server，可以在输入http://localhost:4000/ 查看 或者 按住Command 双击命令行下的网址（http://localhost:4000/）\n这时网页已经成型了。\n接下来就是要部署到gitHub上 只需要在配置文件_config.xml中作如下修改：\ndeploy:  type: git  repo: git@github.com:gavincarter1991/gavincarter1991.github.io  branch: master\n当然gavincarter1991位置还是填你的信息\n然后安装一个自动工具，方便以后页面的部署：\nnpm install hexo-deployer-git --save\n部署去gitHub：\nhexo d\n以后每一次部署的一般步骤：\nhexo cleanhexo ghexo d\n5.写文章首先；\nhexo new post &quot;My First Blog&quot;\n然后去目录：source_posts下找到My First Blog.md（markdown文件）开始编辑文章了。我Mac用的是Mou编辑器，你可以自由选择适合自己的markdown编辑器。这里有markdown使用技巧写好以后就可以按照前面的部署常用步骤进行部署了。\n6. 其他1.主题：hexo有很多第三方主题可以选择，通过git clone2.配置修改参数详见 我写几个常用的：头像：把图片放在主题内 source&#x2F;images&#x2F;，图片链接地址可以填 &#x2F;images&#x2F;avatar.png  然后在当前主题的_config.yml 不是根目录的_config.yml（如果你换了主题，需要根据自己选择的主题进入里面去设置）\n# Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site  directory(source/uploads): /uploads/avatar.jpgavatar: /images/avatar.jpg\n个人中心配置：（根目录的_config.yml）\n# Sitetitle: Gavinsubtitle: 记录成长过程中的点点滴滴description: 我爱敏敏author: kindyourself@163.comlanguage: zh-Hanstimezone:\n显示标签与分类：取消对应注释\n# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash (/archives -&gt; archives)menu:  home: /  categories: /categories  #about: /about  archives: /archives  tags: /tags  #commonweal: /404.html\n然后创建分类\nhexo new page &quot;categories&quot;\n在&#x2F;source&#x2F;categories下有个index.md 按照如下填写：\n---title: categoriesdate: 2016-07-16 02:21:37type: &quot;categories&quot;comments: false---\n\n以后在写文章的时候加上分类就会自动创建分类了\nlayout: &#x27;[layout]&#x27;title: iOS-自定义带抽屉效果的tabBardate: 2016-07-12 23:19:35tags: [自定义，抽屉，tabBar]categories: &quot;iOS&quot; // 分类---\n\n创建标签\nhexo new page &quot;tags&quot;\n在&#x2F;source&#x2F;tags下有个index.md 按照如下填写：\n---title: All tagsdate: 2016-07-16 02:11:12type: &quot;tags&quot;comments: false---\n以后在写文章的时候加上标签就会自动计入\nlayout: &#x27;[layout]&#x27;title: iOS-自定义带抽屉效果的tabBardate: 2016-07-12 23:19:35tags: [自定义，抽屉，tabBar] // 标签categories: &quot;iOS&quot;---\n下载主题：\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n\n7. 总结\n这个在网上还有很多很详细的教程，这是我的大致操作流程。感觉这个可以很简单，就是少去动原生的。如果你想要去捣鼓会发现还是有很多可以捣鼓的，因为他有很多的参数可以配置。我只是配置了一下我觉得在我看来重要的。有兴趣的朋友可以去捣鼓捣鼓。-太晚了，都4点了，睡觉去\n\n","categories":["其他"],"tags":["“hexo”","“个人博客”","“gitHub”"]},{"title":"iOS-js与iOS的交互（基于WKWebViewJavascriptBridge第三方）","url":"/2016/07/09/iOS-js%E4%B8%8EiOS%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%88%E5%9F%BA%E4%BA%8EWKWebViewJavascriptBridge%E7%AC%AC%E4%B8%89%E6%96%B9%EF%BC%89/","content":"\n后天就要去北京出差了，据说那边的项目主要是与网页交互，所以就简单的研究了一下js与iOS的交互。其交互方式有很多种\n\n一、native（app）通过UIWebView的代理方法拦截url scheme判断是否是我们需要拦截处理的url及其所对应的要处理的逻辑（可以实现对网页的返回、前景、刷新），比较通用和简单。self.webView = [[UIWebView alloc]initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.height)];self.webView.delegate = self;[self.webView setUserInteractionEnabled:YES]; //是否支持交互[self.webView setOpaque:NO]; //opaque是不透明的意思[self.webView setScalesPageToFit:YES]; //自动缩放以适应屏幕[self.view addSubview:self.webView];if (sender.tag == 101) &#123;// 返回（点击页面才会有返回）[self.mWebView goBack];&#125;else if (sender.tag == 102) &#123;// 前进（点击过的页面）[self.mWebView goForward];&#125;else &#123;// 刷新页面[self.mWebView reload];&#125;\n\n二、iOS7之后出了JavaScriptCore.framework用于与JS交互，通过JSContext调用JS代码的方法：1、直接调用JS代码\n2、在ObjC中通过JSContext注入模型，然后调用模型的方法\n通过evaluateScript:方法就可以执行JS代码\n三、React Native （不是很了解，只知道是Facebook的，能编译很多的语音，兼容性很强，可移植也很强，有很多很好的原生控件，有兴趣的朋友可以了解一下）四、WebViewJavascriptBridge（第三方）是基于方式一封装的（主要是两个回调函数）。在iOS端：1.self.bridge = [WebViewJavascriptBridge bridgeForWebView:self.webView];\n\n\n链接iOS与js,self.webView就是展示你用来显示需要交换页面的UIWebView\n\n2.[self.bridge registerHandler:@&quot;testJavascriptHandler&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;NSLog(@&quot;ObjC Echo called with: %@&quot;, data);// 反馈给JSresponseCallback(data);&#125;];// 在JS中如果调用了bridge.send()，那么将触发OC端_bridge初始化方法中的回调。// 在JS中调用了bridge.callHandler(&#x27;testJavascriptHandler&#x27;)，它将触发OC端注册的同名方法// oc 同理// JS主动调用OjbC的方法// 这是JS会调用ObjC Echo方法，这是OC注册给JS调用的// JS需要回调，当然JS也可以传参数过来。data就是JS所传的参数，不一定需要传// OC端通过responseCallback回调JS端，JS就可以得到所需要的数据3.[self.bridge callHandler:@&quot;sayHello&quot; data:@&#123;@&quot;hello&quot;: @&quot;你好&quot;&#125; responseCallback:^(id responseData) &#123;NSLog(@&quot;回调结果: %@&quot;, responseData);&#125;];\n\n\n直接调用JS端注册的HandleName，一定注意此次的名字一定要与js端的相同。js调用时也一样\n\n在JS端：\n1.Copy and paste setupWebViewJavascriptBridge into your JS:（此段代码为固定格式，直接放在js端就行）function setupWebViewJavascriptBridge(callback) &#123;if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;window.WVJBCallbacks = [callback];var WVJBIframe = document.createElement(&#x27;iframe&#x27;);WVJBIframe.style.display = &#x27;none&#x27;;WVJBIframe.src = &#x27;wvjbscheme://__BRIDGE_LOADED__&#x27;;document.documentElement.appendChild(WVJBIframe);setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125;\n\n后面几步与iOS端一样\n如有错误，望请指出。\n\n","categories":["iOS"],"tags":["“iOS”","“js”","“WKWebViewJavascriptBridge”"]},{"title":"iOS-webView上加载HTML视频不显示缩略图","url":"/2016/08/08/iOS-webView%E4%B8%8A%E5%8A%A0%E8%BD%BDHTML%E8%A7%86%E9%A2%91%E4%B8%8D%E6%98%BE%E7%A4%BA%E7%BC%A9%E7%95%A5%E5%9B%BE/","content":"\n最近在项目中遇到了一个比较棘手的问题：在原生的iOS的webView上面加载HTML视频发现没有缩略图，在网上查了资料发现在HTML里面有个poster属性（添加一个图片）可以设置缩略图，但是我们的后台告诉我视频资源本来就是来自网络的，没有缩略图只能自己解决了。于是开始是Google模式。终于功夫不负有心人，在一个国外的网站上面发现了一个折中的解决办法。\n\n办法\n其实结局的办法很简单，但是对我这个不是太懂前端的人来说还是……。\n\n\n\n这个方法就是在资源URL的后面（视频格式后面，有的时候视频格式后面还有其他的字符串，我是直接把.mp4后面的直接删除了，但是视频还是可以播放）加上#t&#x3D;xxx,其中的xxx代表的是时间（秒）。大概的思路是这样的：就是在加载视频的时候设置视频的起始时间让视频跳转到你设置的时间上，但是时间一定要足够的小，因为大了前面的视频就看不了了。\n\n这个方法其实还有一个用法：\n\n\n视频会在0：06开始播放直到0：20停止播放。但是这不是自动播放，自动播放需要设置：autoplay&#x3D;”autoplay”。\n\n声明\nNOTE：对于web端我是一个菜鸟，也不知道用这个方法解决这个问题是不是太蠢了，希望谁有其他更好的解决办法可以不吝赐教，谢谢。\n\n","categories":["iOS"],"tags":["“iOS”","“webView”","“视频不显示缩略图”"]},{"title":"iOS-widget-Today 扩展","url":"/2016/07/25/iOS-widget-Today-%E6%89%A9%E5%B1%95/","content":"\n今天要分享的是通知中心扩展中的-Today扩展（ios8推出），ios目前可以使用的扩展有：today扩展（widget-即通知栏的今天一栏）、键盘自定义、文件管理、照片编辑扩展、通知扩展（推送）、分享扩展等。扩展与拥有这个扩展主应用的生命周期是独立的。他们是两个独立的进程。\n\n一、目标：\n我项目是希望在widget中添加一个H5的页面方便以后的自定义。点击对应按钮去到相应界面，我也不知道这样算不算滥用widget，因为之前看见过有人的应用被苹果拒绝就是因为滥用widget导致的。\n\n二、实现：\n1.因为widget是一个单独的进程所以需要创建一个target：\n\n\n\n\n2.代码\n\n- (void)viewDidLoad &#123;    [super viewDidLoad];    // 调整Widget的高度    self.preferredContentSize = CGSizeMake(0, 200);        // 1、创建UIWebView：    UIWebView *mWebView = [[UIWebView alloc]initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 200)];        // 2、设置属性：    mWebView.scalesPageToFit = YES;// 自动对页面进行缩放以适应屏幕    // 检测所有数据类型  设定电话号码、网址、电子邮件和日期等文字变为链接文字        [mWebView setDataDetectorTypes:UIDataDetectorTypeAll];    mWebView.delegate = self;        // 打开URL    NSURLRequest *request =[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];    [mWebView loadRequest:request];    [self.view addSubview:mWebView];        [self makeButtonWithTitle:@&quot;返回&quot; frame:CGRectMake(0, 0, 80, 64) button:_backBtn];    [self makeButtonWithTitle:@&quot;前进&quot; frame:CGRectMake(self.view.frame.size.width - 80, 0, 80, 64) button:_forWardBtn];    [self makeButtonWithTitle:@&quot;刷新&quot; frame:CGRectMake(100, 0, 80, 64) button:_refreshBtn];    &#125;// 取消widget默认的inset，让应用靠左- (UIEdgeInsets)widgetMarginInsetsForProposedMarginInsets:(UIEdgeInsets)defaultMarginInsets &#123;    return UIEdgeInsetsZero;&#125;- (void)makeButtonWithTitle:(NSString *)title frame:(CGRect)frame button:(UIButton *)btn &#123;    btn = [UIButton buttonWithType:UIButtonTypeCustom];    [btn setTitle:title forState:UIControlStateNormal];    [btn setTitleColor:[UIColor redColor] forState:UIControlStateNormal];    [btn addTarget:self action:@selector(skip:) forControlEvents:UIControlEventTouchUpInside];    [btn setFrame:frame];        if ([title isEqualToString:@&quot;返回&quot;]) &#123;        btn.tag = 101;    &#125; else if([title isEqualToString:@&quot;前进&quot;]) &#123;        btn.tag = 102;    &#125;else &#123;        btn.tag = 103;    &#125;    [self.view addSubview:btn];&#125;- (void)skip:(UIButton *)button&#123;    if (button.tag == 101) &#123;        [self.extensionContext openURL:[NSURL URLWithString:@&quot;iOSWidgetApp://action=GotoHomePage&quot;] completionHandler:^(BOOL success) &#123;            NSLog(@&quot;101   open url result:%d&quot;,success);        &#125;];    &#125;    else if(button.tag == 102) &#123;        [self.extensionContext openURL:[NSURL URLWithString:@&quot;iOSWidgetApp://action=GotoOtherPage&quot;] completionHandler:^(BOOL success) &#123;            NSLog(@&quot;102    open url result:%d&quot;,success);        &#125;];    &#125;else &#123;        [self.extensionContext openURL:[NSURL URLWithString:@&quot;iOSWidgetApp://action=GotoOtherPages&quot;] completionHandler:^(BOOL success) &#123;            NSLog(@&quot;102    open url result:%d&quot;,success);        &#125;];    &#125;&#125;\n\n\n运行与结果展示：\n\n\n\n扩展与主程序的交互-数据共享这就要涉及扩展与应用之间的数据共享了-App Groups.\n\n首先在主应用的target &gt; Capabilities下 打开App Groups 点击+ 在group.后面输入标识符，\n\n\n再去扩展的target下进行相同的操作，记得group.后的标识符要一致。\n#####代码：\n\n在上面的扩展代码里面已经定义了点击事件，这里主要是主应用接收到信息后进行判断和处理。\n在这之前还需要先配置URL schems,在主程序的plist里面：\n\n\n- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation &#123;        NSString* prefix = @&quot;iOSWidgetApp://action=&quot;;        UIWebView *webView = [[UIWebView alloc]initWithFrame:[UIScreen mainScreen].bounds];    webView.backgroundColor = [UIColor clearColor];    webView.delegate = self;    [webView setUserInteractionEnabled:YES];//是否支持交互    [webView setOpaque:NO];//opaque是不透明的意思    [webView setScalesPageToFit:YES];//自动缩放以适应屏幕    webView .scrollView.bounces = NO;// 禁止UIWebView下拉拖动效果    NSString *path;    if ([[url absoluteString] rangeOfString:prefix].location != NSNotFound) &#123;        NSString* action = [[url absoluteString] substringFromIndex:prefix.length];        if ([action isEqualToString:@&quot;GotoHomePage&quot;]) &#123;            path = [[NSBundle mainBundle] pathForResource:@&quot;help&quot; ofType:@&quot;html&quot;];        &#125;        else if([action isEqualToString:@&quot;GotoOtherPage&quot;]) &#123;            path = [[NSBundle mainBundle] pathForResource:@&quot;setting&quot; ofType:@&quot;html&quot;];        &#125;else &#123;            path = [[NSBundle mainBundle] pathForResource:@&quot;healthyArticle&quot; ofType:@&quot;html&quot;];        &#125;        NSURL *urll = [NSURL fileURLWithPath:path];        NSURLRequest* request = [NSURLRequest requestWithURL:urll] ;        [webView loadRequest:request];        [self.rootView.view addSubview:webView];        self.rootView.view.backgroundColor = [UIColor whiteColor];    &#125;    return  YES;&#125;\n因为我是需要到对应的H5页面所以是添加的H5页面。\n注意：\n1.当程序内存不足时，苹果优先会杀死扩展，因此需要注意内存的管理。\n2.在配置team是账号需要一致（我测试的时候免费账号好像还不行，需要付费的账号）\n3.在iOS10上面还可以从左滑主页面和锁屏进入widget。\n4.today只有在下拉的时候才会更新，通知栏两边的更新机制是不一样的。\n5.一般更新路径：viewDidLoad-&gt;viewWillAppear，但是如果你下拉过于频繁就只会执行viewWillAppear里面的，因此更新代码最好放在viewWillAppear里面。\n\n如有错误地方，万望指出，谢谢！","categories":["iOS"],"tags":["“iOS”","“widget”","“扩展”"]},{"title":"iOS 下加载本地HTML/js/css/image 等路径问题","url":"/2016/07/25/iOS-%E4%B8%8B%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0HTML-js-css-image-%E7%AD%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","content":"\n今天在项目中遇到一个问题：我将H5的文件拖入项目中，在webView上添加H5,运行时发现H5的样式与图片等都没有了。经过多种测试后发现：是路径的问题。\n在ios项目下添加本地HTML&#x2F;js&#x2F;css&#x2F;image  当拖入项目时有两种选择：\n一个是  Create groups for any added folders（创建虚拟结构-包结构）\n一个是 Create folder references for any added folders 创建实体结构）\n\n\n如果选择前者，当APP编译过后引入的文件会被放在同一个文件夹下面会忽略你原本的文件夹。因此在HTML文件中的路径就会出现问题。如果你选择了前者那么HTML文件中引入CSS，js，图片等就不需要添加前缀路径了，直接写文件名就行。\n\n引入文件方式：\n NSString * htmlPath = [[NSBundle mainBundle] pathForResource:@&quot;index&quot; ofType:@&quot;html&quot;];NSString * htmlString = [NSString stringWithContentsOfFile:htmlPath encoding:NSUTF8StringEncoding error:nil]; NSURL *baseURL = [NSURL fileURLWithPath:[[NSBundle mainBundle] resourcePath]];[self.webView loadHTMLString:htmlString baseURL:baseURL];\n\n 如果选择后者，当APP编译过后引入的文件会按照原本的目录结构存放，这个时候就需要添加相对路径。\n\n 引入文件方式：\n[self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;huaiha/index.html&quot; relativeToURL:[[NSBundle mainBundle] bundleURL]]]];","categories":["iOS"],"tags":["“iOS”","“本地”","“路径问题”"]},{"title":"iOS-自定义带抽屉效果的tabBar","url":"/2016/07/15/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%A6%E6%8A%BD%E5%B1%89%E6%95%88%E6%9E%9C%E7%9A%84tabBar/","content":"demo地址：gitHub\n一、先来个效果\n二、代码示例1.抽屉页作为根视图：\n@interface DrawerViewController ()&#123;    UITapGestureRecognizer *tapGesture;&#125;//创建左边的抽屉@property (nonatomic, strong) LeftViewController *leftViewController;//创建右边的标签控制器@property (nonatomic, strong) MTabBarViewController *mainViewController;//抽屉是否显示的标示@property (nonatomic, assign) BOOL isOpen;@end@implementation DrawerViewController- (void)dealloc&#123;    //移除通知    [[NSNotificationCenter defaultCenter]removeObserver:self name:@&quot;buttonTap&quot; object:nil];&#125;- (void)viewDidLoad &#123;    [super viewDidLoad];        [self createTabBarController];    [self createLeftVc];        self.view.backgroundColor = [UIColor grayColor];        //添加通知，监听TabBar的点击事件 隐藏左边抽屉    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(buttonTap) name:@&quot;buttonTap&quot; object:nil];    &#125;- (void)buttonTap&#123;    //抽屉展开时则隐藏    if (self.isOpen == YES) &#123;        [self openOrHidden];    &#125;    &#125;//创建左边抽屉- (void)createLeftVc&#123;    self.leftViewController = [[LeftViewController alloc]init];        //抽屉控制器添加到父控制器中    [self addChildViewController:self.leftViewController];    self.leftViewController.view.frame = LeftViewStartFrame();    [self.view addSubview:self.leftViewController.view];    [self.leftViewController didMoveToParentViewController:self];    &#125;//创建右边的标签控制器- (void)createTabBarController&#123;    //    NSArray *classNames = @[@&quot;ProductViewController&quot;,@&quot;MessageViewController&quot;,@&quot;OrderViewController&quot;];        //保存viewControllers    NSMutableArray *viewControllers = [NSMutableArray array];    [classNames enumerateObjectsUsingBlock:^(NSString *  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;        //先把字符串转化为类名        Class class = NSClassFromString(obj);                //创建ViewController        UIViewController *vc = [[class alloc]init];        UINavigationController *aNav = [[UINavigationController alloc]initWithRootViewController:vc];                [viewControllers addObject:aNav];            &#125;];    //TabBarController 创建    _mainViewController = [[MTabBarViewController alloc]initWithViewControllers:viewControllers];    _mainViewController.view.backgroundColor = [UIColor brownColor];        //添加标签控制器到父控制器    [self addChildViewController:self.mainViewController];    self.mainViewController.view.frame = BOUNDS;    [self.view addSubview:self.mainViewController.view];    [self.mainViewController didMoveToParentViewController:self];&#125;//标签控制器显示的vc的根控制器的view往右边移动//tabBar -&gt; Nav (ViewControllers[selectedIndex]) -&gt; Nav.rootViewController.view- (void)tabBar_Nav_RootViewController_viewMoveRight&#123;    //标签控制器当中 当前显示的控制器    UINavigationController *nav = self.mainViewController.viewControllers[self.mainViewController.selectedIndex];    //取出导航控制器的根控制器    UIViewController *rootVc = nav.childViewControllers[0];    rootVc.view.frame = RightContentEndFrame();&#125;- (void)tabBar_Nav_RootViewController_viewMoveLeft&#123;    //标签控制器当中 当前显示的控制器    UINavigationController *nav = self.mainViewController.viewControllers[self.mainViewController.selectedIndex];    //取出导航控制器的根控制器    UIViewController *rootVc = nav.childViewControllers[0];    rootVc.view.frame = RigntContentStartFrame();&#125;//显示左边抽屉- (void)open&#123;    [UIView animateWithDuration:0.48 animations:^&#123;        self.leftViewController.view.frame = LeftViewEndFrame();        [self tabBar_Nav_RootViewController_viewMoveRight];    &#125; completion:nil];        //添加点击手势，点击某些区域的隐藏抽屉    tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tap:)];    tapGesture.numberOfTapsRequired = 1;    tapGesture.numberOfTouchesRequired = 1;    [self.view addGestureRecognizer:tapGesture];&#125;- (void)tap:(UITapGestureRecognizer *)gesturer&#123;    //获取点击的位置    CGPoint point = [gesturer locationInView:self.view];    if (CGRectContainsPoint(self.leftViewController.view.frame, point) == YES) &#123;        return;    &#125;        [self hidden];    self.isOpen = NO;    //移除手势    [self.view removeGestureRecognizer:tapGesture];&#125;//隐藏左边抽屉- (void)hidden&#123;    [UIView animateWithDuration:0.48 animations:^&#123;        self.leftViewController.view.frame = LeftViewStartFrame();        [self tabBar_Nav_RootViewController_viewMoveLeft];    &#125; completion:nil];    &#125;- (void)openOrHidden&#123;    //当前如果是隐藏，则显示    if (self.isOpen == NO) &#123;        [self open];    &#125;        //当前如果是显示的，则隐藏    if (self.isOpen == YES) &#123;        [self hidden];    &#125;        //改变隐藏标记    self.isOpen = !self.isOpen;&#125;@end\n\n2.标签视图 修改方法 - (void)selectBtn:(UIButton *)sender中的切换效果可以实现不同的切换动画与效果。\n@implementation MTabBar- (instancetype)initWithTitles:(NSArray *)titles imageNames:(NSArray *)imageNames&#123;    self = [super initWithFrame:TabBarFrame()];    if (self) &#123;                //标题数组不为空，图片名字个数 ＝ 标题个数        self.buttonBack = [[UIView alloc]initWithFrame:CGRM(0, 0, BUTTON_W, 64)];        self.buttonBack.backgroundColor = BUTTON_BACK_COLOR;        [self addSubview:self.buttonBack];                self.backgroundColor = TABBAR_BACK_COLOR;                if ([titles count] &amp;&amp; [titles count] == [imageNames count]) &#123;            [titles enumerateObjectsUsingBlock:^(NSString *  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;                UIButton *button = [[UIButton alloc]initWithFrame:CGRM(BUTTON_W*idx, 0, BUTTON_W, 64)];                button.tag = 1000 + idx;                [self addSubview:button];                //默认选中第一个                if (idx == 0) &#123;                    button.selected = YES;                    self.selectedButton = button;                &#125;                                [button addSubview:MakeLabel(CGRM(0, 30, BUTTON_W, 34), obj)];//                // 图片宽 高分别为 44 24                CGFloat x = (BUTTON_W - 44)/2;                [button addSubview:MakeImageView(CGRM(x, 5, 44, 24),[imageNames objectAtIndex:idx])];                //添加点击方法                [button addTarget:self action:@selector(selectBtn:) forControlEvents:UIControlEventTouchUpInside];            &#125;];        &#125;    &#125;    return self;&#125;//button 点击方法- (void)selectBtn:(UIButton *)sender&#123;    //让抽屉隐藏，发出通知    [[NSNotificationCenter defaultCenter]postNotificationName:@&quot;buttonTap&quot; object:nil];        //选中的button 已经是选中状态 不用处理    if (self.selectedButton == sender) &#123;        return;    &#125;    //改变之前选中button的状态  为非选中状态    self.selectedButton.selected = NO;        //改变当前选中button的状态    sender.selected = YES;    self.selectedButton = sender;    //通知标签控制器显示当前button对应的viewController    if (self.callBack) &#123;        self.callBack(sender.tag - 1000);    &#125;    [UIView animateWithDuration:0.5 animations:^&#123;        self.buttonBack.center = CGPointMake(BUTTON_W/2+(sender.tag - 1000) * BUTTON_W, 32);    &#125; completion:nil];&#125;UILabel *MakeLabel(CGRect frame, NSString *title)&#123;    UILabel *label = [[UILabel alloc]initWithFrame:frame];//    label.userInteractionEnabled = YES;    label.backgroundColor = [UIColor clearColor];    label.textColor = [UIColor whiteColor];    label.textAlignment = NSTextAlignmentCenter;    label.text = title;    return label;&#125;//根据 frame和 imageName 创建UIImageViewUIImageView *MakeImageView(CGRect frame, NSString *imageName)&#123;    UIImageView *imageV = [[UIImageView alloc]initWithFrame:frame];//    imageV.userInteractionEnabled = YES;    imageV.backgroundColor = [UIColor clearColor];    imageV.image = [UIImage imageNamed:imageName];    return imageV;&#125;@end\n\n3.标签控制器\n@interface MTabBarViewController ()@end@implementation MTabBarViewController- (instancetype)initWithViewControllers:(NSArray *)viewControllers&#123;    self = [super init];    if (self) &#123;                _viewControllers = viewControllers;        //遍历数组，添加子控制器        [_viewControllers enumerateObjectsUsingBlock:^(UIViewController *  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;            [self addChild:obj];        &#125;];        /*         @[@&quot;商品.png&quot;,@&quot;消息.png&quot;,@&quot;订单.png&quot;]         @[@&quot;商品浏览&quot;,@&quot;我的消息&quot;,@&quot;我的订单&quot;]         */        _tabBar = [[MTabBar alloc]initWithTitles:@[@&quot;商品浏览&quot;,@&quot;我的消息&quot;,@&quot;我的订单&quot;] imageNames:@[@&quot;商品.png&quot;,@&quot;消息.png&quot;,@&quot;订单.png&quot;]];        [self.view addSubview:self.tabBar];        __weak typeof(self) weakSelf = self;        self.tabBar.callBack = ^(NSInteger index)&#123;            weakSelf.selectedIndex = index;        &#125;;        //默认选中第0个        self.selectedIndex = 0;    &#125;    return self;&#125;- (void)setSelectedIndex:(NSInteger)selectedIndex&#123;    //取出当前控制器 oldVc    UIViewController *oldVc = self.viewControllers[self.selectedIndex];    //取出将要显示的 控制器 newVc    UIViewController *newVc = self.viewControllers[selectedIndex];    //动画 向左边移动    newVc.view.frame = CGRectMake(S_W, 0, S_W, S_H);    //改变 newVc 的视图层次        //把newVc.view 的视图放在 self.tabBar 的下面    [self.view insertSubview:newVc.view belowSubview:self.tabBar];    [UIView animateWithDuration:0.5 animations:^&#123;        oldVc.view.frame = CGRectMake(-S_W, 0, S_W, S_H);        newVc.view.frame = BOUNDS;    &#125;];    _selectedIndex = selectedIndex;&#125;//添加子控制器具体步骤- (void)addChild:(UIViewController *)viewController&#123;    [self addChildViewController:viewController];    viewController.view.frame = BOUNDS;    //将viewContoller.view 放在最底层    [self.view insertSubview:viewController.view atIndex:0];    [viewController didMoveToParentViewController:self];    //    self.view.subviews 数组 下标越小，视图层次越在下面，下标越大，视图层次越在上面&#125;@end\n\n4.视图位置控制 修改对应的视图的frame可以实现不同的视图效果\nCGRect TabBarFrame()&#123;    return CGRectMake(0, S_H-64, S_W, 64);&#125;//左边抽屉隐藏（开始）的位置CGRect LeftViewStartFrame()&#123;    return CGRectMake(-S_W*0.75, 67,S_W*0.75 , S_H-64-64-6);&#125;//左边抽屉显示（结束）的位置CGRect LeftViewEndFrame()&#123;    return CGRectMake(0, 67, S_W*0.75, S_H-64-64-6);&#125;//右边内容开始（抽屉隐藏时）的位置CGRect RigntContentStartFrame()&#123;    return CGRectMake(0, 0, S_W, S_H);&#125;//右边内容结束（抽屉显示时）的位置CGRect RightContentEndFrame()&#123;    return CGRectMake(S_W*0.75, 0, S_W, S_H);&#125;CGRect CGRM(CGFloat x, CGFloat y,CGFloat w,CGFloat h)&#123;    return CGRectMake(x, y, w, h);&#125;@end\n\n\n\n欢迎下载\n\n","categories":["iOS"],"tags":["“iOS”","“抽屉”","“tabBar”"]},{"title":"iOS-解压zip","url":"/2016/07/09/iOS-%E8%A7%A3%E5%8E%8Bzip/","content":"\n最近的项目中涉及到了将zip文件从服务上下载下来，然后解压使用。搜索了一下发现有一个压缩与解压zip文件的第三方“SSZipArchive”：https://github.com/ZipArchive/ZipArchive 是用C语言实现的，包装用于OC与swift.\n\n一、在使用过程中遇到过几个坑：\n导入头文件冲突，我在pch文件里面导入了一些OC的头文件，而SSZipArchive是由C语言实现的，所以报了很多的系统错误。解决办法：将pch里面的导入头文件代码放在“#ifdef OBJC&#x2F;&#x2F;导入头文件“#endif 里面”  或者删除里面导入头文件的代码，去具体需要的文件里面导入，有一点暴力哈。\n\n我每一次下载的文件样式都是一样的，所以希望覆盖式的解压，一开始没有注意以为它只有解压方法：+ (BOOL)unzipFileAtPath:(NSString *)path toDestination:(NSString *)destination;就自己去判定是否存在然后删除，后来去仔细的看源码才发现它是有带是否覆盖式解压的方法：+ (BOOL)unzipFileAtPath:(NSString *)path toDestination:(NSString *)destination overwrite:(BOOL)overwrite password:(NSString *)password error:(NSError * *)error;当然它还有很多方法，包括带有代理方法，带有密码，带有完成后的block回调方法，http://blog.csdn.net/zhengang007/article/details/51019479这里有每一个方法的详细说明。\n\n\n二、我的实现：- (void)downFileFromServer&#123;//远程地址NSURL *URL = [NSURL URLWithString:DOWN_URL];//默认配置NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];//AFN3.0+基于封住URLSession的句柄AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];//请求NSURLRequest *request = [NSURLRequest requestWithURL:URL];//下载Task操作_downloadTask = [manager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123;// 下载进度&#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;//- block的返回值, 要求返回一个URL, 返回的这个URL就是文件的位置的路径NSString *cachesPath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];NSString *path = [cachesPath stringByAppendingPathComponent:response.suggestedFilename];return [NSURL fileURLWithPath:path];&#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;//设置下载完成操作// filePath就是你下载文件的位置，你可以解压，也可以直接拿来使用NSString *imgFilePath = [filePath path];// 将NSURL转成NSStringMyLog(@&quot;imgFilePath = %@&quot;,imgFilePath);NSArray *documentArray =  NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);NSString *path = [[documentArray lastObject] stringByAppendingPathComponent:@&quot;Preferences&quot;];[self releaseZipFilesWithUnzipFileAtPath:imgFilePath Destination:path];&#125;];[_downloadTask resume];&#125;// 解压- (void)releaseZipFilesWithUnzipFileAtPath:(NSString *)zipPath Destination:(NSString *)unzipPath&#123;NSError *error;if ([SSZipArchive unzipFileAtPath:zipPath toDestination:unzipPath overwrite:YES password:nil error:&amp;error delegate:self]) &#123;MyLog(@&quot;success&quot;);MyLog(@&quot;unzipPath = %@&quot;,unzipPath);&#125;else &#123;MyLog(@&quot;%@&quot;,error);&#125;&#125;#pragma mark - SSZipArchiveDelegate- (void)zipArchiveWillUnzipArchiveAtPath:(NSString *)path zipInfo:(unz_global_info)zipInfo &#123;MyLog(@&quot;将要解压。&quot;);&#125;- (void)zipArchiveDidUnzipArchiveAtPath:(NSString *)path zipInfo:(unz_global_info)zipInfo unzippedPath:(NSString *)unzippedPat uniqueId:(NSString *)uniqueId &#123;MyLog(@&quot;解压完成！&quot;);&#125;\n\n当然还得遵守协议：SSZipArchiveDelegate以上就是我使用SSZipArchive的体会，欢迎各位指正。\n\n","categories":["iOS"],"tags":["“iOS”","“解压zip”"]},{"title":"iOS-高德地图","url":"/2016/07/09/iOS-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/","content":"\n一直以来在简书上学习了不少的知识，自己也想分享一些知识供大家指点，最近正好在研究高德地图API，所以分享一下自己最近捣鼓的。要使用高德API，首先要去高德API官网注册开发者账号，创建应用，获得key值。然后在本地创建自己的项目pod高德SDK，在pod时要提前思考清楚是否需要导航，我在这里就被坑过，因为导航的SDK包含搜索的SDK，如果将搜索SDK与导航SDK都pod了会报链接错误，所以如果需要导航就可以不用pod搜索SDK了。最后就是本地导入相应头文件，然后配置key。\n\nconst static NSString *APIKey = @&quot;你申请的key&quot;;// 配置用户Key[MAMapServices sharedServices].apiKey = (NSString *)APIKey;// 搜索[AMapSearchServices sharedServices].apiKey = (NSString *)APIKey;// 导航[AMapNaviServices sharedServices].apiKey = (NSString *)APIKey;\n\n\n后面的就可以按照它的开发指南写，要注意的是路径规划是建立在路径搜索之上的，要路径规划先得完成路径搜索。导航的语音合成，我是用的讯飞的在线语音合成，离线的好像要收费，在下穷猿一名。高德导航的demo好像也是用的讯飞的。去讯飞API官网注册账号，创建应用，获取key，然后配置语音。\n\n//设置sdk的log等级，log保存在下面设置的工作路径中[IFlySetting setLogFile:LVL_ALL];//打开输出在console的log开关[IFlySetting showLogcat:YES];//设置sdk的工作路径NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);NSString *cachePath = [paths objectAtIndex:0];[IFlySetting setLogFilePath:cachePath];// 配置相关参数- (void)configIFlySpeech&#123;[IFlySpeechUtility createUtility:[NSString stringWithFormat:@&quot;appid=%@,timeout=%@&quot;,@&quot;5733feca&quot;,@&quot;20000&quot;]];[IFlySetting setLogFile:LVL_NONE];[IFlySetting showLogcat:NO];// 设置语音合成的参数[[IFlySpeechSynthesizer sharedInstance] setParameter:@&quot;50&quot; forKey:[IFlySpeechConstant SPEED]];//合成的语速,取值范围 0~100[[IFlySpeechSynthesizer sharedInstance] setParameter:@&quot;50&quot; forKey:[IFlySpeechConstant VOLUME]];//合成的音量;取值范围 0~100// 发音人,默认为”xiaoyan”;可以设置的参数列表可参考个 性化发音人列表;[[IFlySpeechSynthesizer sharedInstance] setParameter:@&quot;xiaowang&quot; forKey:[IFlySpeechConstant VOICE_NAME]];// 音频采样率,目前支持的采样率有 16000 和 8000;[[IFlySpeechSynthesizer sharedInstance] setParameter:@&quot;8000&quot; forKey:[IFlySpeechConstant SAMPLE_RATE]];// 当你再不需要保存音频时，请在必要的地方加上这行。[[IFlySpeechSynthesizer sharedInstance] setParameter:nil forKey:[IFlySpeechConstant TTS_AUDIO_PATH]];&#125;然后初始化和设置代理。- (void)initIFlySpeech &#123;if (self.iFlySpeechSynthesizer == nil)&#123;_iFlySpeechSynthesizer = [IFlySpeechSynthesizer sharedInstance];&#125;_iFlySpeechSynthesizer.delegate = self;&#125;// 语音失败回调代理函数- (void)onCompleted:(IFlySpeechError *)error &#123;NSLog(@&quot;Speak Error:&#123;%d:%@&#125;&quot;, error.errorCode, error.errorDesc);&#125;\n\n\n高德导航有一个回调函数，会传回导航语音的字符串，在回调函数里面创建异步线程，将字符串合成语音，并且播放，在高德导航点击关闭按钮的回调函数里面关闭播放并且关闭导航。\n\n####pragma mark – 语音调用（导航回调）\n- (void)naviManager:(AMapNaviManager *)naviManager playNaviSoundString:(NSString *)soundString soundStringType:(AMapNaviSoundType)soundStringType &#123;if (soundStringType == AMapNaviSoundTypePassedReminder) &#123;// 系统语音AudioServicesPlaySystemSound(1009);&#125;else &#123;// 开启异步线程（全局）dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^&#123;[_iFlySpeechSynthesizer startSpeaking:soundString];&#125;);&#125;&#125;// 这是点击关闭按钮的回调函数（就是导航界面的叉叉）- (void)naviViewControllerCloseButtonClicked:(AMapNaviViewController *)naviViewController &#123;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^&#123;[self.iFlySpeechSynthesizer stopSpeaking];&#125;);[self.naviManager stopNavi];[self.naviManager dismissNaviViewControllerAnimated:YES];&#125;\n\n\n以上就是我最近研究的高德API，一是对最近学习的总结，二是希望帮助刚刚接触高德的人，希望对你们有帮助，文章写得有点乱，第一次啊，以后肯定会越来越好。如有错误欢迎各位指出。谢谢。\n\n","categories":["iOS"],"tags":["“iOS”","“高德地图”"]},{"title":"与web前端朋友闲聊的发现-代码相通性","url":"/2016/07/15/%E4%B8%8Eweb%E5%89%8D%E7%AB%AF%E6%9C%8B%E5%8F%8B%E9%97%B2%E8%81%8A%E7%9A%84%E5%8F%91%E7%8E%B0-%E4%BB%A3%E7%A0%81%E7%9B%B8%E9%80%9A%E6%80%A7/","content":"缘起\n  今天与一个做web前端的哥们闲聊了一会，他今天遇到了一个问题：就是在做一个混合开发的APP时候，他们H5端有一个页面需要做搜索，就是在搜索框内输入能够实时的展示搜索结果。\n\n想法与问题\n他想监听了搜索框并且实时的进行数据的请求。后来发现输入的过程一直在进行远程数据的请求，他觉得这样消耗太大了。于是想做一个延时的操作，就是等用户稍微停止输入的时候才去远程请求数据。可是没有理清这个逻辑，于是他的方法相当的复杂，好像是要将每一实时输入的数据存入数组，然后进行对比，当延时完成进行对比决定请求的数据。\n\n插曲\n但是他在这个过程中发现了一个问题，就是延时操作并没有减少网络请求的次数。这个问题在前段时间的项目中我也遇到了，就是延时操作并不是重复了，就不执行了，延时操作只是延缓操作时间，每一次的延时都会被执行。所以想要减少执行次就必须在延时操作未执行 前取消延时操作。取消的延时操作如果还没有执行，就不会执行了而不是取消后就立即执行。\n\n讨论\n这时候我想起几天前在简书上看见一个哥们写了一篇关于如何防止button被重复点击的文章，他一共介绍了三种方法，他的第二种方法：\n\n[button addTarget:self action:@selector(click:) forControlEvents:UIControlEventTouchUpInside]- (void)click:(UIButton *)sender &#123;       [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(btnClicke) object:nil];       [self performSelector:@selector(btnClicke) withObject:nil afterDelay:1];  &#125;  \n\n\n就是用的延时操作他的是在button的方法里面先取消延时方法，再添加延时方法，这个对于防止button重复点击来说并不是好的方法，因为这样会影响用户的体验，每次点击button不能及时的进行响应。但是对于我朋友的这个问题却是一个很好的选择。他原本就想减缓请求次数。\n\n结论\n我发现编程语言是相通的，虽然各有各的语法，但是实现思路是一样的，特此记录。\n\n","categories":["其他"],"tags":["“iOS”","“web”","“代码相通性”"]},{"title":"微信小程序tips","url":"/2017/02/22/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Ftips/","content":"\n最近公司项目改版，趁产品修改与UI出图的间歇用公司商户端UI图撸了一把微信小程序。因为刚刚实习那一会接触过前端开发，所以上手还比较快，当然也遇到了很多的问题，不过好在基本按图完成。趁此总结一下我遇到的问题,奉上一些可行的解决方案，希望可以帮助与我遇到相同问题的朋友。demo \n\n先上图\ntips背景图片不能使用本地的\n\n这个问题坑了我很久，因为在模拟器上跑时，将本地图片作为View的背景图片是可以的，但是一到真机测试就不显示背景图片了，一开始还以为是路径错了，经过测试发现路径是没有问题的，最后在网上找到了原因：微信小程序的背景图片不能是本地图片，必须是是网络图片，于是我就找了一个网站将图片传了上去，将网址作为背景图片链接，就奇迹般的显示了，很是无语。\n\n不能加载网页\n微信小程序是不能跳转到网页的，也许是因为微信小程序本身就如同网页吧，也可能是微信不想有人越过它的审核，反正他是不允许直接加载网页的。\n\n不能隐藏导航栏\n我的登陆页面本来是不应该有导航栏的，可是就是隐藏不了，也许有方法，但是我找了很久也没有发现。\n\n只支持HTTPS的网络协议并且一个月只能修改5次\n在微信小程序中网络请求只能是https类型的。在添加URL的时候都已经限制死了。并且一个月只能修改5次，网络请求必须先进行服务器域名配置。\n\n)\n所有的页面都必须在app.json中配置路径\n我之前新建一个页面然后跳转过去一直报路径错误，去网上查询才知道，每一个页面路径都需要提前配置。\n\n\n网络请求的最大并发数为5、页面层级最多5层\n就是说同时最多5个网络请求，页面的子页面最多4个。我在想要是一个页面是一个视频列表展示怎么办，每一个视频都需要网络请求啊。\n以上就是这次遇到的一些比较变态的问题。\n\n谈谈我的一些代码实现配置tabBar(app.json)\n&quot;tabBar&quot;: &#123;  &quot;color&quot;: &quot;#888888&quot;,  &quot;selectedColor&quot;: &quot;#09BB07&quot;,  &quot;backgroundColor&quot;: &quot;&quot;,  &quot;borderStyle&quot;: &quot;white&quot;,  &quot;list&quot;: [    &#123;      &quot;pagePath&quot;: &quot;pages/orderManage/orderManage&quot;,      &quot;text&quot;: &quot;订单管理&quot;,      &quot;iconPath&quot;: &quot;pages/images/order.png&quot;,      &quot;selectedIconPath&quot;: &quot;pages/images/order_r.png&quot;    &#125;,    &#123;      &quot;pagePath&quot;: &quot;pages/moneyManage/moneyManage&quot;,      &quot;text&quot;: &quot;财务管理&quot;,      &quot;iconPath&quot;: &quot;pages/images/money.png&quot;,      &quot;selectedIconPath&quot;: &quot;pages/images/money_r.png&quot;    &#125;,    &#123;      &quot;pagePath&quot;: &quot;pages/myself/myself&quot;,      &quot;text&quot;: &quot;我的商户&quot;,      &quot;iconPath&quot;: &quot;pages/images/people.png&quot;,      &quot;selectedIconPath&quot;: &quot;pages/images/people_r.png&quot;    &#125;    ]&#125;\n订单管理页的菜单栏\n点击菜单栏切换View简单，直接将将点击的菜单的值赋给View让其偏移对应的百分比就好。\n手势切换：通过触摸的起点与终点计算出滑动方向，然后偏移并且切换菜单栏。\n\n    catchtouchstart:function(e)&#123;    var that = this;    that.setData(&#123;      startPoint: [e.touches[0].clientX,e.touches[0].clientY]    &#125;)  &#125;,  catchtouchend:function(e)&#123;    var that = this;    var currentNum = parseInt(this.data.currentNavtab);    var endPoint = [e.changedTouches[0].clientX,e.changedTouches[0].clientY];    var startPoint = that.data.startPoint    if(endPoint[0] &lt;= startPoint[0]) &#123;      if(Math.abs(endPoint[0] - startPoint[0]) &gt;= Math.abs(endPoint[1] - startPoint[1]) &amp;&amp; currentNum&lt; this.data.navTab.length -1) &#123;         currentNum=currentNum + 1;        &#125;    &#125;else &#123;      if(Math.abs(endPoint[0] - startPoint[0]) &gt;= Math.abs(endPoint[1] - startPoint[1]) &amp;&amp; currentNum &gt; 0) &#123;          currentNum -= 1;      &#125;    &#125;    this.setData(&#123;      currentNavtab: currentNum    &#125;);  &#125;,// 点击菜单栏切换View  switchTab: function(e)&#123;    this.setData(&#123;      currentNavtab: e.currentTarget.dataset.idx    &#125;);  &#125;\n\n结束\n整个程序还是很简单的，就是初次写还是有些不适应。尤其是把div改为了View，不能使用window对象和document对象，很不适应。再次奉上demo\n\n","categories":["微信小程序"],"tags":["“微信小程序”"]},{"title":"iOS集成融云SDK即时通讯整理","url":"/2018/03/29/iOS%E9%9B%86%E6%88%90%E8%9E%8D%E4%BA%91SDK%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E6%95%B4%E7%90%86/","content":"iOS集成融云SDK即时通讯整理\n最近很少写一下项目总结了，最近项目虽然做了很多，但是都是一些外包项目，做下来也没有什么值得总结的。最近一个项目用到了融云即时通讯，以前基本都是用环信，所以还遇到了一些问题，在此总结一下记录一下。\n\n头像、昵称等用户信息(融云对这个问题有两种处理方式)用户信息提供者\n\n实现步骤(以下代码放在单例中，可以是AppDelegate，最好单独写一个单例)  \n首先遵守RCIMUserInfoDataSource这个协议 \n\n然后是要设置代理\n[[RCIM sharedRCIM] setUserInfoDataSource:self]; \n最后实现代理方法：\n- (void)getUserInfoWithUserId:(NSString *)userId completion:(void (^)(RCUserInfo *))completion &#123;    NSLog(@&quot;getUserInfoWithUserId ----- %@&quot;, userId);    RCUserInfo *user = [RCUserInfo new];    if (userId == nil || [userId length] == 0) &#123;        user.userId = userId;        user.portraitUri = @&quot;&quot;;        user.name = @&quot;&quot;;        completion(user);        return;    &#125;        if ([userId isEqualToString:[UserInfo shareInstance].uid]) &#123;        NSString *urlSelf = [BASIC_URL_image stringByAppendingString:[UserInfo shareInstance].photo];        return completion([[RCUserInfo alloc] initWithUserId:userId name:[UserInfo shareInstance].nickname portrait:urlSelf]);    &#125;else &#123;      //根据存储联系人信息的模型，通过 userId 来取得对应的name和头像url，进行以下设置    [WTBaseHttpRequst postRequstWithURL:getUserHttp params:@&#123;@&quot;uid&quot;:[UserInfo shareInstance].uid, @&quot;api_token&quot;:[UserInfo shareInstance].api_token, @&quot;k_uid&quot;:userId&#125; successBlock:^(NSDictionary *returnData) &#123;        if ([returnData[@&quot;status&quot;] integerValue] == 1) &#123;            NSString *urlStr = [BASIC_URL_image stringByAppendingString:returnData[@&quot;data&quot;][@&quot;user&quot;][@&quot;photo&quot;]];            return completion([[RCUserInfo alloc] initWithUserId:userId name:returnData[@&quot;data&quot;][@&quot;user&quot;][@&quot;nickname&quot;] portrait:urlStr]);        &#125;else &#123;            completion(user);        &#125;    &#125; failureBlock:^(NSString *error) &#123;        completion(user);    &#125; showHUD:NO];&#125;&#125;\n这个方法不需要你自己手动调用，只是当你在修改用户信息时调用方法即可\n[[RCIM sharedRCIM] refreshUserInfoCache:user withUserId:[UserInfo shareInstance].uid]\n\nWS(weakSelf);// 修改用户信息调用[WTBaseHttpRequst postRequstWithURL:modifyInfoHttp params:dict successBlock:^(NSDictionary *returnData) &#123;    [weakSelf MBProgressHudShowWithTextOnlyWithText:returnData[@&quot;msg&quot;]];    if ([returnData[@&quot;status&quot;] integerValue] == 1) &#123;        RCUserInfo *user = [RCUserInfo new];        user.userId = [UserInfo shareInstance].uid;        user.portraitUri = [BASIC_URL_image stringByAppendingString:[UserInfo shareInstance].photo];        user.name = weakSelf.nickNameTextField.text;        [[RCIM sharedRCIM] refreshUserInfoCache:user withUserId:[UserInfo shareInstance].uid];        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;            [self.navigationController popViewControllerAnimated:YES];        &#125;);    &#125;&#125; failureBlock:^(NSString *error) &#123;    [weakSelf MBProgressHudShowWithTextOnlyWithText:error];&#125; showHUD:YES];\n\n在扩展消息中携带用户信息\n\n设置发送消息时在消息体中携带用户信息(从2.4.1 之后附加用户信息之后cell默认会显示附加的用户信息的头像，即用户信息不会取用户信息提供者里提供的用户信息)\n\n[RCIM sharedRCIM].enableMessageAttachUserInfo = YES; ```    **你设置了enableMessageAttachUserInfo之后，可以取到**\n&#x2F;**  \n\n发送者信息\n**&#x2F;@property(nonatomic, strong) RCUserInfo *senderUserInfo;    **当然我觉得还可以从后台获取好友关系后，我们在每次登陆后，开一个线程把好友关系请求下来存起来然后根据环信ID查找好友的昵称和头像**### 给输入框添加提示语(这个我一直觉得环信应该给了方法修改，只是我一直没有找到这个方法，所以只有自己去写了)  **创建提示的label**\n_lab &#x3D; [[UILabel alloc] initWithFrame:self.chatSessionInputBarControl.inputTextView.bounds];_lab.text &#x3D; @”请输入文字信息…”;_lab.textColor &#x3D; [UIColor colorWithHexColor:@”dddddd”];_lab.font &#x3D; [UIFont systemFontOfSize:15];_lab.center &#x3D; CGPointMake(_lab.center.x + 15, _lab.center.y);**判定是否有草稿来显示和隐藏提示的label**\n[self.chatSessionInputBarControl.inputTextView addSubview:_lab];if (self.chatSessionInputBarControl.draft &#x3D;&#x3D; nil || self.chatSessionInputBarControl.draft.length &#x3D;&#x3D; 0) { _lab.hidden &#x3D; NO;}else { _lab.hidden &#x3D; YES;}**根据输入数据来判定显示隐藏提示label**\n\n\n(void)inputTextView:(UITextView *)inputTextView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text {  if (((inputTextView.text.length &#x3D;&#x3D; 1 &amp;&amp; [text isEqualToString:@””]) || (inputTextView.text.length &#x3D;&#x3D; 0 &amp;&amp; text.length &gt; 0))  &amp;&amp; range.length &#x3D;&#x3D; 1 &amp;&amp; range.location &#x3D;&#x3D; 0) {  _lab.hidden &#x3D; NO;  }else {  _lab.hidden &#x3D; YES;  }}### 取消输入@弹出好友列表界面，保留长按头像@方法**首先在AppDelegate中开启消息@功能（只支持群聊和讨论组, App需要实现群成员数据源groupMemberDataSource）**\n[RCIM sharedRCIM].enableMessageMentioned &#x3D; YES;\n\n然后在继承RCConversationViewController的控制器中调用-(void)showChooseUserViewController:(void (^)(RCUserInfo *selectedUserInfo))selectedBlock                         cancel:(void (^)())cancelBlock {}\n### 在会话列表中添加一些固定的cell(继承RCConversationListViewController)\n&#x2F;&#x2F; 对自定义cell赋值\n\n(RCConversationBaseCell *)rcConversationListTableView:(UITableView *)tableView                            cellForRowAtIndexPath:(NSIndexPath *)indexPath {  RCCustomCell *cell &#x3D; (RCCustomCell *)[[RCCustomCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@”RCCustomCell”];  RCConversationModel *model &#x3D; self.conversationListDataSource[indexPath.row];  cell.nameLabel.text &#x3D; model.conversationTitle;  return cell;}\n\n&#x2F;&#x2F; 添加自定义cell的数据源\n\n(NSMutableArray *)willReloadTableData:(NSMutableArray *)dataSource{  NSArray *arr &#x3D; @[@”论坛回复和@我的”, @”陌生人私信”, @”幸存者部落@我的”, @”问卷调查”];  for (int i &#x3D; 0; i&lt;arr.count; i++) {  RCConversationModel *model &#x3D; [[RCConversationModel alloc]init];  model.conversationModelType &#x3D; RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;  model.conversationTitle &#x3D; arr[i];  model.isTop &#x3D; YES;  [dataSource insertObject:model atIndex:i];  }  return dataSource;}\n\n&#x2F;&#x2F; 点击cell跳转\n\n(void)onSelectedTableRow:(RCConversationModelType)conversationModelType   conversationModel:(RCConversationModel *)model     atIndexPath:(NSIndexPath *)indexPath{  if (indexPath.row &#x3D;&#x3D; 0) {  WTForumAndConnectListViewController *chatList &#x3D; (WTForumAndConnectListViewController *)[WTStoryBoardSegment instantiateViewControllerWithStoryBoardName:@”Main” identifier:@”WTForumAndConnectListViewController”];  chatList.title &#x3D; @”回复和@我的”;  [self.navigationController pushViewController:chatList animated:YES];  }else if (indexPath.row &#x3D;&#x3D; 1) {  WTChatListViewController *chatList &#x3D; [[WTChatListViewController alloc] init];  chatList.title &#x3D; @”陌生人私信”;  chatList.isEnteredToCollectionViewController &#x3D; YES;  chatList.type &#x3D; 1;  chatList.friendArray &#x3D; self.friendArray;  [self.navigationController pushViewController:chatList animated:YES];  }else if (indexPath.row &#x3D;&#x3D; 2) {  WTChatListViewController *chatList &#x3D; [[WTChatListViewController alloc] init];  chatList.title &#x3D; @”幸存者部落@我的”;  chatList.isEnteredToCollectionViewController &#x3D; YES;  chatList.type &#x3D; 2;  [self.navigationController pushViewController:chatList animated:YES];  }else if (indexPath.row &#x3D;&#x3D; 3) {  WTQuestionnaireViewController *questionnaire &#x3D; (WTQuestionnaireViewController *)[WTStoryBoardSegment instantiateViewControllerWithStoryBoardName:@”Main” identifier:@”WTQuestionnaireViewController”];  [self.navigationController pushViewController:questionnaire animated:YES];  }else {  &#x2F;&#x2F;点击cell，拿到cell对应的model，然后从model中拿到对应的RCUserInfo，然后赋值会话属性，进入会话  if (model.conversationType &#x3D;&#x3D; ConversationType_PRIVATE) {&#x2F;&#x2F;单聊      WTMyConversationLisViewController *_conversationVC &#x3D; [[WTMyConversationLisViewController alloc]init];      _conversationVC.conversationType &#x3D; model.conversationType;      _conversationVC.targetId &#x3D; model.targetId;      _conversationVC.title &#x3D; model.conversationTitle;      [self.navigationController pushViewController:_conversationVC animated:YES];  }else if (model.conversationType &#x3D;&#x3D; ConversationType_GROUP){&#x2F;&#x2F;群聊      WTMyConversationLisViewController *_conversationVC &#x3D; [[WTMyConversationLisViewController alloc]init];      _conversationVC.conversationType &#x3D; model.conversationType;      _conversationVC.title &#x3D; model.conversationTitle;      _conversationVC.targetId &#x3D; model.targetId;      [self.navigationController pushViewController:_conversationVC animated:YES];  }  }}### 在任意地方获取聊天列表数量及删除列表**获取聊天列表**   \nNSArray *privateArr &#x3D; [[RCIMClient sharedRCIMClient] getConversationList:@[@(ConversationType_PRIVATE)]];**在ConversationList添加对应类型的聊天就可以获取对应类型的聊天列表删除方法类似**\n[[RCIMClient sharedRCIMClient] clearConversations:@[@(ConversationType_PRIVATE)]];\n\n\n### 背景图\n\n&gt; 融云聊天列表没有数据的默认图片下面有点击右上角加入聊天，可是不是所有的聊天都有这个功能(我的就没有)如何没有就可以在资源文件中找到 no\\_message\\_img 这张图片用ps去掉下面的那一行字\n\n### 其它\n\n&gt; 以上就是我在使用融云过程中遇到的一些问题及解决方法，如果有错误或者不足之处还望指正，谢谢！\n\n","categories":["iOS"],"tags":["“iOS”","“融云”"]},{"title":"图片上传预览","url":"/2016/08/01/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%A2%84%E8%A7%88/","content":"\n本周帮一哥们写了一个页面遇到了一些问题，特此记录一下。主要遇到的问题是图片上传预览（多个上传控件）、多个颜色选择，遇到了冲突。\n\n\n这是代码上传的HTML部分代码\n&lt;div id=&quot;home11&quot; class=&quot;tab-pane in active lowerContent &quot;&gt;                  &lt;div class=&quot;tool floatLeft&quot;&gt;                    &lt;span class=&quot;spanStylef floatLeft&quot;&gt;名称&lt;/span&gt;                    &lt;input type=&quot;text&quot; name=&quot;appName&quot;&gt;                  &lt;/div&gt;                  &lt;div class=&quot;upImage floatLeft&quot;&gt;                    &lt;div class=&quot;tool floatLeft&quot;&gt;                      &lt;span class=&quot;spanStylef floatLeft&quot;&gt;默认图标&lt;/span&gt;                      &lt;a href=&quot;javascript:;&quot; class=&quot;file&quot; onchange=&quot;javascript:setImagePreview(2);&quot;&gt;上传图片                        &lt;input type=&quot;file&quot; name=&quot;imagereview2&quot; class =&quot;inputImages&quot;&gt;                      &lt;/a&gt;                    &lt;/div&gt;                    &lt;div class=&quot;tool floatLeft&quot;&gt;                      &lt;span class=&quot;spanStylef floatLeft&quot;&gt;&amp;nbsp&lt;/span&gt;                      &lt;img class=&quot;imagereview2&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;                    &lt;/div&gt;                  &lt;/div&gt;                  &lt;div class=&quot;upImage floatLeft&quot;&gt;                    &lt;div class=&quot;tool floatLeft&quot;&gt;                      &lt;span class=&quot;spanStylef floatLeft&quot;&gt;触及图标&lt;/span&gt;                      &lt;a href=&quot;javascript:;&quot; class=&quot;file&quot; onchange=&quot;javascript:setImagePreview(3);&quot;&gt;上传图片                        &lt;input type=&quot;file&quot; name=&quot;imagereview3&quot; class =&quot;inputImages&quot;&gt;                      &lt;/a&gt;                    &lt;/div&gt;                    &lt;div class=&quot;tool floatLeft&quot;&gt;                      &lt;span class=&quot;spanStylef floatLeft&quot;&gt;&amp;nbsp&lt;/span&gt;                      &lt;img class=&quot;imagereview3&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;                    &lt;/div&gt;                  &lt;/div&gt;                &lt;/div&gt;\n\n修改上传按钮的部分css代码\n.file &#123;    position: relative;    display: inline-block;    background: #D0EEFF;    border: 1px solid #99D3F5;    border-radius: 4px;    padding: 4px 12px;    overflow: hidden;    color: #1E88C7;    text-decoration: none;    text-indent: 0;    line-height: 20px;&#125;.file input &#123;    position: absolute;    font-size: 100px;    right: 0;    top: 0;    opacity: 0;&#125;.file:hover &#123;    text-decoration: none;&#125;\n\n这是JS部分的代码\nfunction setImagePreview(avalue) &#123;               //input               var docObjs = document.getElementsByClassName(&quot;inputImages&quot;);               var docObj = docObjs[avalue];               if (docObj.files &amp;&amp; docObj.files[0]) &#123;                   var imgObjPreviews = document.getElementsByClassName(docObj.name);                   var imgObjPreview = imgObjPreviews[0];               if (avalue == 0) &#123;                   imgObjPreview.style.display = &#x27;block&#x27;;                   imgObjPreview.style.width = &#x27;200px&#x27;;                   imgObjPreview.style.height = &#x27;350px&#x27;;               &#125;else &#123;                   //火狐下，直接设img属性                   imgObjPreview.style.display = &#x27;block&#x27;;                   imgObjPreview.style.width = &#x27;100px&#x27;;                   imgObjPreview.style.height = &#x27;100px&#x27;;               &#125;                  imgObjPreview.src = window.URL.createObjectURL(docObj.files[0]);               &#125; else &#123;                   //IE下，使用滤镜                   // docObj.select();                   // var imgSrc = document.selection.createRange().text;                   // var localImagId = document.getElementById(&quot;localImag&quot;);                   // //必须设置初始大小                   // localImagId.style.width = &quot;100px&quot;;                   // localImagId.style.height = &quot;100px&quot;;                   // //图片异常的捕捉，防止用户修改后缀来伪造图片                   // try &#123;                   //     localImagId.style.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=scale)&quot;;                   //     localImagId.filters.item(&quot;DXImageTransform.Microsoft.AlphaImageLoader&quot;).src = imgSrc;                   // &#125; catch(e) &#123;                   //     alert(&quot;您上传的图片格式不正确，请重新选择!&quot;);                   //     return false;                   // &#125;                   // imgObjPreview.style.display = &#x27;none&#x27;;                   // document.selection.empty();               &#125;               return true;           &#125;           \n\n问题与解决：问题一：是上传按钮默认的文件上传是这样的\n但是我需要的是这样的：\n\n解决方案：就是将fileAPI放在你需要的控件上面，然后将fileAPI设置为透明，然后点击你需要的控件其实就是点击了fileAPI。还有一个方案就是用js:将你的控件的点击事件里面的返回为fileAPI的事件。这样点击你的控件就完成了fileAPI事件了，（我想的，没有去实现喔）\n\n问题二：点击事件冲突\n一开始我是通过id选择器来标记image与input的,后来发现多个上传按钮就需要多个js判定，会有很多的重复代码。于是后来我改为了用类选择器但是类名一样无法将image与input对应。于是我将input的name与与image的类名写成一样，通过input的name找到对应的image。\n\nNOTE：我前端开发很久没有弄了，很多忘记了，如有错误。请亲们一定要指出啊！","categories":["web"],"tags":["“web”","“图片上传”","“预览”"]},{"title":"Widget进阶","url":"/2025/06/07/widget-advanced/","content":"1.Widget 介绍\nEverything is a widget 这是你学习 flutter 会听到的最多的一句话。因为在 Flutter 中几乎所有的对象都是一个 widget，在 flutter 中 UI 的构建和事件的处理基本都是通过 widget 的组合及嵌套来完成的。在 iOS 中我们经常提及的“组件”、“控件”在 flutter 中就是 widget，当然 widget 的范围比之更加广泛。如：手势检测 GestureDetector、主题 Theme 和动画容器 AnimatedContainer 等也是 widget。\n\nFlutter 默认支持的两种设计风格：\n\n1.Material components Design： 谷歌（android）的 UI 风格，主要为 Android 设计，但也支持跨平台使用。\n\n\n2.Cupertino Design： 苹果（iOS）的 UI 风格，模仿苹果原生 UIKit 风格。高度还原 iOS 原生体验，适合需要与苹果生态一致的应用。\n\n2.Widget 分类1.按状态管理\n一、StatelessWidget：无状态组件，通过 build 方法返回静态 UI。不可变，属性（final）在创建后无法修改，适用于不需要内部状态变化的场景（如文本显示、图标），不依赖用户交互或数据变化的 UI 部分。\nclass IconTextButton extends StatelessWidget &#123;  final String iconName;  final String label;  final VoidCallback onPressed;  const IconTextButton(&#123;    super.key,    required this.iconName,    required this.label,    required this.onPressed,  &#125;);  @override  Widget build(BuildContext context) &#123;    return GestureDetector(      onTap: onPressed,      child: Column(        mainAxisAlignment: MainAxisAlignment.center,        children: &lt;Widget&gt;[          Image.asset(            &quot;assets/images/$iconName.png&quot;,            width: 40,            height: 40,          ),          const SizedBox(            height: 10,          ), // 图标          Text(            label,            style: const TextStyle(color: ColorConstant.color33, fontSize: 10),          ), // 文字        ],      ),    );  &#125;&#125;\n\n二、StatefulWidget：有状态组件，通过 State 对象管理动态数据。当状态变化时调用 setState 触发 UI 更新，需要用户交互（如按钮点击、表单输入）和依赖实时数据变化（如计数器、动态列表）。\n// 上下滚动的消息轮播class MarqueeWidget extends StatefulWidget &#123;  /// 子视图数量  final int count;  ///子视图构建器  final IndexedWidgetBuilder itemBuilder;  ///轮播的时间间隔  final int loopSeconds;  const MarqueeWidget(&#123;    super.key,    required this.count,    required this.itemBuilder,    this.loopSeconds = 5,  &#125;);  @override  _MarqueeWidgetState createState() =&gt; _MarqueeWidgetState();&#125;class _MarqueeWidgetState extends State&lt;MarqueeWidget&gt; &#123;  late PageController _controller;  late Timer _timer;  @override  void initState() &#123;    super.initState();    _controller = PageController();    _timer = Timer.periodic(Duration(seconds: widget.loopSeconds), (timer) &#123;      if (_controller.page != null) &#123;        // 如果当前位于最后一页，则直接跳转到第一页，两者内容相同，跳转时视觉上无感知        if (_controller.page!.round() &gt;= widget.count) &#123;          _controller.jumpToPage(0);        &#125;        _controller.nextPage(            duration: const Duration(seconds: 1), curve: Curves.linear);      &#125;    &#125;);  &#125;  @override  Widget build(BuildContext context) &#123;    return PageView.builder(      scrollDirection: Axis.vertical,      controller: _controller,      itemBuilder: (buildContext, index) &#123;        if (index &lt; widget.count) &#123;          return widget.itemBuilder(buildContext, index);        &#125; else &#123;          return widget.itemBuilder(buildContext, 0);        &#125;      &#125;,      itemCount: widget.count + 1,    );  &#125;  @override  void dispose() &#123;    super.dispose();    _controller.dispose();    _timer.cancel();  &#125;&#125;\n\n2.按功能分类\n\n1.布局类 Widget： 控制子 Widget 的排列方式。\n\n常见有：Row/Column：水平/垂直排列子项（基于 Flexbox）。Stack：子 Widget 堆叠（类似 CSS 的绝对定位）。Expanded/Flexible：在 Row 或 Column 中分配剩余空间。Container：结合布局、装饰、边距等功能\n\n\n2.基础组件 Widget： 构成 UI 的基本元素。\n\n常见有：Text：显示文本。Image：加载本地或网络图片。Icon：显示图标（需引入 cupertino_icons 或自定义图标库）\n\n\n3.滚动类 Widget： 处理内容超出屏幕时的滚动行为。\n\n常见有：ListView：垂直/水平滚动列表。GridView：网格布局滚动视图。SingleChildScrollView：包裹单个可滚动子组件。\n\n\n4.交互类 Widget： 响应用户输入事件。\n\n常见有：ElevatedButton/TextButton：按钮交互。TextField：文本输入框。Checkbox/Switch：选择控件。GestureDetector：自定义手势检测（点击、长按、拖动）。\n\n\n5.平台风格类 Widget： 适配不同操作系统的视觉风格。\n\n常见有：Material Design：MaterialApp、AppBar、FloatingActionButton。Cupertino（iOS 风格）：CupertinoApp、CupertinoNavigationBar、CupertinoPicker。\n\n\n6.动画类 Widget： 实现动态视觉效果。\n\n常见有：AnimatedContainer：自动过渡的容器（大小、颜色等属性变化）。Hero：页面切换共享元素的过渡动画。AnimatedBuilder：自定义复杂动画。\n\n\n7. 导航与路由类 Widget： 管理页面跳转和导航结构。\n\n常见有：Navigator：管理页面堆栈（push/pop）。PageView：实现滑动切换页面。BottomNavigationBar：底部导航栏。\n\n\n通过简单 Widget 组合实现复杂 UI（例如用 Row + Expanded 替代自定义布局）(优先组合而非继承)局部状态使用 StatefulWidget全局状态使用状态管理工具（如 Provider、Riverpod）对频繁更新的部分使用 const 构造函数长列表使用 ListView.builder 懒加载\n\n3.Widget 生命周期StatelessWidget 的生命周期\n\nStatelessWidget 仅有一个 build() 方法，无状态管理逻辑，其生命周期完全由父组件控制。\n\nStatefulWidget 主要生命周期方法\n\n创建阶段createState()\n\n\n初始化阶段initState()didChangeDependencies()\n\n\n更新阶段didUpdateWidget(oldWidget)build()\n\n\n销毁阶段deactivate()dispose()\n\n\n1.createState()当 StatefulWidget 被插入 Widget 树时调用，而且只执行一次。\n\n主要用于创建与之关联的 State 对象（每个 Widget 对应一个 State 实例）。\n\nclass MyWidget extends StatefulWidget &#123;  @override  _MyWidgetState createState() =&gt; _MyWidgetState();&#125;\n\n2.initState()在 State 对象创建后，首次调用 build() 之前触发该方法，而且只执行一次。\n\n主要用于初始化依赖数据（如订阅事件、加载本地配置）和 创建动画控制器（AnimationController）等需与 dispose() 配对的资源。\n\n@overridevoid initState() &#123;  super.initState();  _controller = AnimationController(vsync: this);  _fetchData(); // 初始化数据&#125;\n\n需要注意的是：必须调用 super.initState()。在这里 View 并没有渲染，只是 StatefulWidget 被加载到渲染树里了。避免在此处触发 setState（可能导致渲染未完成）。StatefulWidget的 mount 的值变为了true（调用dispose()才会变为 false）。\n3.didChangeDependencies()initState() 后立即调用 didChangeDependencies()。当 State 依赖的 InheritedWidget 发生变化时（如主题、本地化）也会调用 didChangeDependencies()。\n\n主要用于处理依赖变化后的逻辑（如重新请求网络数据）。\n\n@overridevoid didChangeDependencies() &#123;  super.didChangeDependencies();  if (Provider.of&lt;Data&gt;(context).hasChanged) &#123;    _updateData();  &#125;&#125;\n\n4. didUpdateWidget(oldWidget)在父组件重建时，若新旧 Widget 的 runtimeType 和 key 相同触发 didUpdateWidget（didUpdateWidget 我们一般不会用到）。\n\n主要是：对比新旧 Widget 的配置（如属性变化）。根据变化调整状态（如重置动画、更新监听）。\n\n@overridevoid didUpdateWidget(MyWidget oldWidget) &#123;  super.didUpdateWidget(oldWidget);  if (oldWidget.color != widget.color) &#123;    _updateColor(); // 颜色变化时执行逻辑  &#125;&#125;\n\n5. build()初始化后、依赖变化后、setState() 调用后调用 build()。父组件或祖先组件触发重建时调用 build()。\n\n主要是根据当前状态构建 UI（不要在这里做除了创建 Widget 之外的操作）\n\n@overrideWidget build(BuildContext context) &#123;  return Container(    color: widget.color,    child: Text(&#x27;Count: $_count&#x27;),  );&#125;\n\n需要注意的是：必须返回一个 Widget避免在此处修改状态或执行耗时操作\n6. deactivate()当 State 从树中暂时移除（如页面切换、组件被移除）触发 deactivate()。\n\n清理临时资源或保存临时状态.\n\n需要注意的是：可能被重新插入树中（如页面返回时），需与 dispose() 区分\n7. dispose()State 被永久移除时调用 dispose()。\n\n释放资源（如取消网络请求、销毁动画控制器）\n\n@overridevoid dispose() &#123;  _controller.dispose(); // 销毁动画控制器  _subscription.cancel(); // 取消事件订阅  super.dispose();&#125;\n\n需要注意的是：如果在 dispose() 中未释放资源（如动画控制器、Stream 订阅）可能造成内存泄漏如果在 dispose() 后调用 setState 会导致异常\n4.Widget 的渲染渲染流程：Flutter 的渲染系统基于三棵核心树结构，通过高度优化的管线（Pipeline）实现高效的 UI 更新。\n\nWidget 重建 → Diff 新旧 Widget 树 → 更新 Element 树 → 更新 RenderObject 树 → 触发 Layer 合成 → 屏幕刷新\n\n1.Widget 树的构建：\n\n描述 UI 的不可变配置，由开发者创建，频繁重建，需轻量化。开发者编写的 Widget 代码被转化为嵌套的 Widget 树（应用的入口是根 Widget，一般是 MaterialApp 或 CupertinoApp。根 Widget 会递归地构建其子 Widget，形成一棵树。）。具有不可变性，每次重建生成全新的 Widget 树，但通过 Diff 算法可以优化实际更新范围。\n\n2. Element 树的 Diff 与更新\n\n根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 Element 类。Element 是 Widget 的实例化对象，负责管理 状态（State） 和 子节点引用。每个 Widget 都会有一个对应的 Element 对象，用于管理其生命周期。\n\n\nDiff 算法：Flutter 对比新旧 Widget 树，仅更新变化的 Element 和 RenderObject，类似 React 的虚拟 DOM。当 Widget 树重建时，Flutter 通过 Diff 算法 对比新旧 Widget 树，决定 Element 树的更新策略Reuse：若新旧 Widget 的 runtimeType 和 key 相同，复用现有 Element。Update：更新 Element 的配置（调用 Element.update(newWidget)）。Replace：类型或 Key 不同时，销毁旧 Element，创建新 Element。\n\n// 旧 Widget 树Container(color: Colors.red)// 新 Widget 树Container(color: Colors.blue)// Diff 结果：Container 类型相同且无 Key → 复用 Element，更新 RenderObject 颜色\n\n// Element 更新逻辑Element.updateChild()Element updateChild(Element child, Widget newWidget, dynamic newSlot) &#123;  if (newWidget == null) &#123;    // 移除子节点    return null;  &#125;  if (child != null) &#123;    if (child.widget == newWidget) &#123;      // Widget 未变化 → 复用 Element      return child;    &#125;    if (Widget.canUpdate(child.widget, newWidget)) &#123;      // 更新 Element 配置      child.update(newWidget);      return child;    &#125;    // 销毁旧 Element，创建新 Element    deactivateChild(child);  &#125;  return inflateWidget(newWidget, newSlot);&#125;\n\n3. RenderObject 树的更新\n更新 RenderObject 树，计算布局和生成绘制指令。运行在 UI Thread。\n\n根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自 RenderObject 类。每个 Element 对应一个 RenderObject（通过 Element.createRenderObject() 创建）。\n\n\n根据父 RenderObject 传递的 约束（Constraints），计算自身尺寸和位置。递归调用子节点的 layout() 方法（深度优先遍历）。\n\n布局（Layout）核心方法：\n// RenderObject 布局流程RenderObject.layout()void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123;  _constraints = constraints;  if (_relayoutBoundary != this) &#123;    markNeedsLayout();    return;  &#125;  performLayout();  // 1. 计算自身尺寸（调用 performLayout） 由子类实现具体布局逻辑  _needsLayout = false;  markNeedsPaint(); // 标记需要重绘&#125;\n\n\n生成绘制指令（如形状、颜色、文本），写入 Layer（合成层）。\n\n绘制（Paint）核心方法:\nvoid paint(PaintingContext context, Offset offset) &#123;  // 绘制逻辑，如画矩形  context.canvas.drawRect(rect, paint);&#125;\n\n4. 合成与光栅化（Composition &amp; Rasterization）\n生成 Layer 树并光栅化。运行在 Raster Thread（与 UI Thread 并行）\n\n根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 Layer 类。RenderObject 的绘制结果被组织为 Layer 树，每个 Layer 对应一个 GPU 纹理（Texture）。自此 Layer 树生成。类型包括：PictureLayer（矢量绘制）、TextureLayer（图像纹理）、TransformLayer（变换效果）等。\n\n\n将 Layer 树中的绘制指令转换为 GPU 可识别的位图数据。通过 Skia 图形库（或 Impeller）完成，最终提交给 GPU 渲染。（完成光栅化（Raster Thread））。\n\nvoid paintChild(RenderObject child, Offset offset) &#123;  if (child.isRepaintBoundary) &#123;    // 创建独立 Layer    stopRecordingIfNeeded();    child._layer = OffsetLayer();    appendLayer(child._layer);  &#125; else &#123;    child._paintWithContext(this, offset);  &#125;&#125;\n\n5. GPU 渲染与屏幕刷新\n\n垂直同步（VSync）：由系统定时触发的信号，控制帧率（如 60Hz → 16.6ms&#x2F;帧）。Flutter 引擎在 VSync 信号到来时，提交光栅化后的帧数据到 GPU。\n\n\n屏幕显示：GPU 将帧数据写入帧缓冲区（Frame Buffer），屏幕硬件按刷新率读取并显示。\n\n5.Widget 优化高性能渲染 = 最小化 Widget Diff + 高效布局/绘制 + GPU 线程优化\n\nFlutter 优化的本质是 减少无效计算 和 降低 GPU 负载一般围绕四个方向： 1.最小化 Widget 树 Diff 范围 2.减少布局（Layout）和绘制（Paint）计算 3.优化 GPU 合成与光栅化（Rasterization） 4.高效管理状态与资源\n\n\n性能分析工具Flutter DevTools：Performance 面板：分析 UI&#x2F;Raster 线程的帧耗时。Layer 查看器：检测 Layer 合成是否合理。debugProfileBuildsEnabled：追踪 Widget 构建耗时调试标记：debugPrintMarkNeedsLayoutStacks：打印触发布局的堆栈信息。debugPaintLayerBordersEnabled：可视化 Layer 边界。\n\n1.Widget 树 Diff 优化\n\nDiff 算法机制： 当父组件更新时，Flutter 递归对比新旧 Widget 树，判断是否需要更新 Element 和 RenderObject。\n\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) &#123;  return oldWidget.runtimeType == newWidget.runtimeType      &amp;&amp; oldWidget.key == newWidget.key;&#125;\n\n\n复用条件： runtimeType 和 key 相同 → 复用 Element，仅更新配置。替换条件： 类型或 Key 不同 → 销毁旧 Element，创建新 Element。\n\n优化策略：1.使用 const 构造函数： const Widget 在多次重建中引用同一内存地址，Widget.canUpdate 直接返回 true，跳过 Diff 计算。\nconst MyWidget(text: &#x27;Hello&#x27;); // ✅ 优化MyWidget(text: &#x27;Hello&#x27;);      // ❌ 非 const\n\n2.合理使用 Key： ValueKey：在列表项中标识唯一性，避免错误复用导致状态混乱。GlobalKey：跨组件访问状态（谨慎使用，破坏局部性）。\nListView.builder(  itemBuilder: (_, index) =&gt; ItemWidget(    key: ValueKey(items[index].id), // 唯一标识    data: items[index],  ),)\n\n3.拆分细粒度 Widget： 将频繁变化的部分拆分为独立 Widget，缩小 setState 触发的 Diff 范围。\n// 父组件（仅传递静态数据）class ParentWidget extends StatelessWidget &#123;  const ParentWidget(&#123;super.key&#125;);  @override  Widget build(BuildContext context) &#123;    return Column(      children: [        const StaticHeader(), // 静态部分        DynamicContent(data: _data), // 动态部分      ],    );  &#125;&#125;\n\n2.布局（Layout）阶段优化\n\n布局计算机制： 当某个 RenderObject 的尺寸变化不影响父节点布局时，可标记为布局边界，阻断布局计算向上传播。通过 RenderObject.isRepaintBoundary &#x3D; true 设置（布局边界（Relayout Boundary））\n\n\n父节点传递 约束（Constraints） 给子节点子节点根据约束计算自身尺寸，并递归布局子节点(布局过程)\n\n优化策略\n\n1.避免过度嵌套： 多层 Row&#x2F;Column 会导致布局计算复杂度呈指数增长。我们可以使用 Flex、Wrap 或自定义布局逻辑替代嵌套。\n\n\n2.预计算尺寸： 通过固定尺寸（SizedBox）或 LayoutBuilder 提前确定布局约束，减少计算量。\n\nSizedBox(  width: 100,  height: 50,  child: Text(&#x27;Fixed Size&#x27;),)\n\n\n3.使用 IntrinsicWidth&#x2F;IntrinsicHeight 的替代方案： IntrinsicWidth 会触发多次子节点布局计算，性能低下。我们可以手动计算子节点最大宽度，使用 ConstrainedBox 限制尺寸。\n\n3.绘制（Paint）阶段优化\n\n绘制机制： 当 RenderObject 的视觉属性（如颜色、位置）变化时，调用 markNeedsPaint() 标记需要重绘。\n\n\n合成层（Layer）： 每个 RenderObject 的绘制结果被组织为 Layer 树，最终由 GPU 光栅化。（PictureLayer（矢量绘制）、TextureLayer（图像）、TransformLayer（变换））。\n\n优化策略\n\n1.使用 RepaintBoundary： 将独立变化的 UI 部分包裹 RepaintBoundary，生成独立 Layer，减少重绘区域。通过 RenderObject.isRepaintBoundary &#x3D; true 标记。\n\nRepaintBoundary(  child: MyAnimatedWidget(), // 独立重绘区域)\n\n\n2.避免高开销绘制操作： 使用 AnimatedOpacity 或直接设置颜色透明度（Color.withOpacity）替代 Opacity 。优先使用 ClipRect 或 ClipRRect，减少路径裁剪的计算量。\n\n\n3.自定义绘制优化： 在 CustomPainter 中精确控制重绘条件。\n\nclass MyPainter extends CustomPainter &#123;  @override  bool shouldRepaint(MyPainter old) &#123;    return old.color != color; // 仅颜色变化时重绘  &#125;&#125;\n\n4.GPU 合成与光栅化优化\n\n1.光栅化机制： 通过上面的合成与光栅化可知道：光栅化运行在独立的 Raster Thread，与 UI Thread 并行。Flutter 自动复用未变化的 Layer 对应的 GPU 纹理，减少数据传输。（纹理（Texture）复用）\n\n优化策略\n\n1.减少 Layer 数量： 过多的 Layer 会增加 GPU 合成开销，我们需要尽可能的合并相邻的 PictureLayer，避免不必要的 Opacity 或 Transform 嵌套。\n\n\n2.使用硬件加速操作： 利用 GPU 的矩阵变换硬件加速（Transform 替代手动矩阵计算）。对重复使用的图片提前解码（precacheImage） （Image 预加载）。\n\n\n3.启用 Impeller 引擎： Flutter 3.0+ 引入的 Impeller 引擎针对 GPU 负载优化，减少光栅化抖动。\n\n5.状态管理与资源优化\n\n1.状态管理：局部状态：使用 StatefulWidget 管理，确保 dispose() 释放资源。全局状态：采用 Provider、Riverpod 或 Bloc，避免状态穿透和冗余重建。\n\n\n2.资源释放：必须释放动画控制器（AnimationController.dispose()）、Stream 订阅（Subscription.cancel()）等资源。\n\n@overridevoid dispose() &#123;  _controller.dispose();  _streamSubscription.cancel();  super.dispose();&#125;\n\n\n","categories":["Flutter"],"tags":["“Flutter”","“Widget”"]},{"title":"项目剖析01-swift WebSocket","url":"/2019/12/23/%E9%A1%B9%E7%9B%AE%E5%89%96%E6%9E%9001-swift-WebSocket/","content":"\n已经很长一段时间没有总结项目了，正好最近完成项目第二版的改版(新项目完全是用swift写的)，就把项目中一些有意义的知识块在此记录一下， 项目中有实时的交易需要展示，所以用到了socket长链接，我用的是Starscream这个第三方库，集成方法很简单去网站看看就知道。\n\n先上代码import UIKitimport Reachabilityimport Starscreamimport zliblet reachability = Reachability()! // 判断网络连接let webSocket = WTWebsocket.sharedvar reConnectTime = 0 // 设置重连次数let reConnectMaxTime = 1000 // 设置最大重连次数let reConnectIntervalTime: TimeInterval = 15 // 设置重连时间间隔(秒)var websocketTimer: Timer? = nilvar reConnectSubscribeDict:[String : Any] = [:]var page = &quot;home&quot;var isReconnect = truefinal class WTWebsocket: NSObject,WebSocketDelegate &#123;        var isPingBack = true    var myWebsocket: WebSocket? = nil    //  socket连接上函数    func websocketDidConnect(socket: WebSocketClient) &#123;        //设置重连次数，解决无限重连问题        reConnectTime = 0        if reConnectSubscribeDict.count &gt; 0 &#123;            self.subscribe(subscribeDict: reConnectSubscribeDict)        &#125;        self.hearJump()        if  websocketTimer == nil &#123;            websocketTimer = Timer.scheduledTimer(timeInterval: reConnectIntervalTime, target: self, selector: #selector(sendBrandStr), userInfo: nil, repeats: true)        &#125;        isReconnect = true    &#125;        //发送文字消息    @objc func sendBrandStr()&#123;        self.checkPing()        let json = getJSONStringFromDictionary(dictionary: [&quot;topic&quot;:&quot;PING&quot;])        SingletonSocket.sharedInstance.socket.write(string: json)    &#125;        // 发送ping    func hearJump() &#123;        let json = getJSONStringFromDictionary(dictionary: [&quot;topic&quot;:&quot;PING&quot;])        SingletonSocket.sharedInstance.socket.write(string: json)    &#125;        //  socket断开执行函数    func websocketDidDisconnect(socket: WebSocketClient, error: Error?) &#123;        //执行重新连接方法        socketReconnect()    &#125;        //  接收返回消息函数    func websocketDidReceiveMessage(socket: WebSocketClient, text: String) &#123;    &#125;        func websocketDidReceiveData(socket: WebSocketClient, data: Data) &#123;        guard let newStr = String(data: data.gzipUncompress(), encoding: .utf8) else &#123;return&#125;        if newStr == &quot;PONG&quot; &#123;            isPingBack = true            return        &#125;      // 处理收到的信息    &#125;        // 添加注册    func subscribe(subscribeDict: [String : Any]) &#123;        var subscribeDicts = subscribeDict        reConnectSubscribeDict = subscribeDicts        page = subscribeDicts[&quot;type&quot;] as! String        subscribeDicts.removeValue(forKey: &quot;type&quot;)        let json = getJSONStringFromDictionary(dictionary:            subscribeDicts as NSDictionary)        SingletonSocket.sharedInstance.socket.write(string: json)    &#125;        //检测    @objc func checkPing() &#123;        if !isPingBack &#123;            // 重新连接            socketReconnect()        &#125;else &#123;            isPingBack = false        &#125;    &#125;    //构造单例数据    static let shared = WTWebsocket()    private override init() &#123;    &#125;&#125;//socket 重连逻辑func socketReconnect() &#123;    //判断网络情况，如果网络正常，可以执行重连    if reachability.connection != .none &#123;        //设置重连次数，解决无限重连问题        reConnectTime =  reConnectTime + 1        if reConnectTime &lt; reConnectMaxTime &#123;            //添加重连延时执行，防止某个时间段，全部执行            let time: TimeInterval = 2.0            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + time) &#123;                SingletonSocket.sharedInstance.socket.connect()                SingletonSocket.sharedInstance.socket.disconnect()            &#125;        &#125; else &#123;            //提示重连失败        &#125;    &#125; else &#123;        //提示无网络    &#125;&#125;//socket主动断开，放在app进入后台时，数据进入缓存。app再进入前台，app出现卡死的情况func socketDisConnect() &#123;    if !SingletonSocket.sharedInstance.socket.isConnected &#123;        websocketTimer?.invalidate()        websocketTimer = nil        SingletonSocket.sharedInstance.socket.disconnect()    &#125;&#125;// initSocket方法func initWebSocketSingle () &#123;    SingletonSocket.sharedInstance.socket.delegate = webSocket&#125;//声明webSocket单例class SingletonSocket &#123;    let socket:WebSocket = WebSocket(url: URL(string: AppURLHOST.SocketURL)!)    class var sharedInstance : SingletonSocket&#123;        struct Static&#123;            static let instance:SingletonSocket = SingletonSocket()        &#125;        if !Static.instance.socket.isConnected&#123;            Static.instance.socket.connect()        &#125;        return Static.instance    &#125;&#125;\n整个代码很简单，基本都有注释，大概聊一聊里面的一些关键点\n发送ping-俗称发送心跳，这个主要是判断socket是否断开，链接成功后每次间隔固定时间发送一次请求，然后在返回中修改isPingBack，在下一次发送请求前检查isPingBack判断上一次的请求是否返回，这样就可以判断socket是否断开，这个间隔时间可以自由设定，但是最好不要太短，太短有可能是socket连接了但是没有来得及返回。当然太长也不行，这可能导致发现socket断开不及时。\n\napp在后台需要断开socket，当 app重新进入前台需要重新连接\nfunc applicationWillResignActive(_ application: UIApplication) &#123;        //进入后台模式，主动断开socket，防止出现处理不了的情况        if SingletonSocket.sharedInstance.socket.isConnected &#123;            reConnectTime = reConnectMaxTime            socketDisConnect()        &#125;    &#125;    func applicationDidBecomeActive(_ application: UIApplication) &#123;        //进入前台模式，主动连接socket        //解决因为网络切换或链接不稳定问题，引起socket断连问题        //如果app从无网络，到回复网络，需要执行重连        if !isFirstApplicationDidBecomeActive &#123;            reConnectTime = 0            socketReconnect()            WTBasicConfigManager.shareDataSingle.getHash()        &#125;        isFirstApplicationDidBecomeActive = false    &#125;\n\n一定要设置最大重新连接的次数，不然app会无限重新连接\n连接成功或者重连成功都需要对需要推送的数据进行一次网络请求，确保数据的准确性。\n\n以上就是我在项目中使用WebSocket的方法，如果有错误或者不足之处还望指正，谢谢\n\n","categories":["swift"],"tags":["“swift”","“WebSocket”"]},{"title":"项目剖析02-swift 轻松实现动画效果-Lottie","url":"/2019/12/23/%E9%A1%B9%E7%9B%AE%E5%89%96%E6%9E%9002-swift-%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C-Lottie/","content":"\nLottie 是 Airbnb开源的一套跨平台的动画效果解决方案,它能够同时支持iOS、Android、Web 和 React Native的开发，设计师只需要用 AdobeAfterEffects(AE) 设计出需要的的动画之后，使用 Lottie 提供的 Bodymovin 插件将设计好的动画导出成JSON格式(文件很小不会象GIF那么庞大)给你即可，可以让设计师实现所见即所得的动画再也不用和设计师争论动画设计了。本文只是展示在swift中如何简单使用Lottie ，详细的使用方法请参考官方文档\n\n\n用法举例lazy var lottieAnimationView: AnimationView = &#123;        // 加载本地资源        let path : String = Bundle.main.path(forResource: &quot;data&quot;, ofType: &quot;json&quot;)!        let lottieAnimationView = AnimationView.init(filePath: path)        WTNavigationManger.Nav?.view.addSubview(lottieAnimationView)        lottieAnimationView.constrain(toSuperviewEdges: nil)        lottieAnimationView.isUserInteractionEnabled = true        lottieAnimationView.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(removeLottieAnimationViewFromParent)))        return lottieAnimationView    &#125;()// 调用lottieAnimationView.play &#123;[weak self] (complete) in       guard let mySelf = self else &#123;return&#125;       mySelf.removeLottieAnimationViewFromParent()    &#125;@objc func removeLottieAnimationViewFromParent() &#123;        lottieAnimationView.removeFromSuperview()    &#125;\n\n\n将设计师给你的文件导入项目，然后通过Bundle.main.path(forResource:找到json文件，然后将AnimationView添加到视图，在需要展示动画的地方调用play() 方法，这样动画就可以加载了。\n\n引入json的方式/// json所在的文件，默认为Bundle.mainlet animation = Animation.named(&quot;StarAnimation&quot;) /// 默认为Bundle.mainlet animation = Animation.named(&quot;StarAnimation&quot;, bundle: myBundle)/// subdirectory 为动画所在的包中的子目录(可选的)let animation = Animation.named(&quot;StarAnimation&quot;, subdirectory: &quot;Animations&quot;)/// animationCache 为保存加载动画的缓存(可选的)let animation = Animation.named(&quot;StarAnimation&quot;, animationCache: LRUAnimationCache.sharedCache)\n\n指定加载路径Animation.filepath(_ filepath: String, animationCache: AnimationCacheProvider?) -&gt; Animation?\n\n从绝对文件路径加载动画模型。如果没有找到动画，则返回nilfilepath:要加载的动画的绝对文件路径animationCache:用于保存加载的动画的缓存(可选的)\n\n播放动画基本播放(Basic Playing)\n// 播放动画从它的当前状态到它的时间轴结束。在动画停止时调用completion代码块// 如果动画完成，则completion返回true。如果动画被中断，则返回falseAnimationView.play(completion: LottieCompletionBlock?)\n利用进度时间(Play with Progress Time)\n// 指定一个时间到另一个时间的播放AnimationView.play(fromProgress: AnimationProgressTime?, toProgress: AnimationProgressTime, loopMode: LottieLoopMode?, completion: LottieCompletionBlock?)\n时间帧播放(Play with Marker Names)\n// 动画播放从一个时间帧到另一个时间帧AnimationView.play(fromFrame: AnimationProgressTime?, toFrame: AnimationFrameTime, loopMode: LottieLoopMode?, completion: LottieCompletionBlock?)\n时间帧播放(Play with Marker Names)\n// 将动画从命名标记播放到另一个标记。标记是编码到动画数据中并指定名称的时间点AnimationView.play(fromMarker: String?, toMarker: String, loopMode: LottieLoopMode?, completion: LottieCompletionBlock?)\n其它操作\n\nAnimationView.pause() &#x2F;&#x2F; 暂停\n\nAnimationView.stop()  &#x2F;&#x2F; 停止\n\nvar AnimationView.backgroundBehavior: LottieBackgroundBehavior { get set} &#x2F;&#x2F; app进入后台\n\nvar AnimationView.contentMode: UIViewContentMode { get set } &#x2F;&#x2F; 循环播放模式。默认是playOnce，还有autoReverse无限循环\n\nvar AnimationView.isAnimationPlaying: Bool { get set } &#x2F;&#x2F; 判断动画是否在播放\n\nvar AnimationView.animationSpeed: CGFloat { get set } &#x2F;&#x2F; 动画速度\n\nfunc AnimationView.forceDisplayUpdate() &#x2F;&#x2F; 强制重绘动画视图\n\n\n\n以上就是我在项目中使用Lottie的方法，如果有错误或者不足之处还望指正，谢谢\n","categories":["iOS"],"tags":["“iOS”","“动画”","“Lottie”"]},{"title":"项目剖析03-swift 网络请求Moya+HandyJSON+RxSwift","url":"/2019/12/23/%E9%A1%B9%E7%9B%AE%E5%89%96%E6%9E%9003-swift-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82Moya-HandyJSON-RxSwift/","content":"\n项目第一版网络框架用的是siesta,它的缓存与自动刷新确实很好用而且代码很简洁，但是在文件的上传与下载以及对返回类型需要精确匹配要求这方面就很不友好，所以在第二版的我选择了Moya,它是一个网络抽象层，它在Alamofire基础上提供了一系列的抽象接口方便维护。关于Moya的使用介绍很多，我就不再赘述了。我主要记录一下我在使用过程中学到的处理方式。我的网络框架是搭着HandyJSON和RxSwift一起构建的。\n\nMoya代码\nimport Foundationimport enum Result.Resultimport Alamofire//设置请求超时时间private let requestTimeoutClosure = &#123; (endpoint: Endpoint, done: @escaping MoyaProvider&lt;ApiManager&gt;.RequestResultClosure) in    do &#123;        var request = try endpoint.urlRequest()        request.timeoutInterval = 60        done(.success(request))    &#125; catch &#123;        return    &#125;&#125;let ApiManagerProvider = MoyaProvider&lt;ApiManager&gt;(endpointClosure: endpointMapping, requestClosure: requestTimeoutClosure, plugins:[])// MARK: 取消所有请求func cancelAllRequest() &#123;    WTOtherProvider.manager.session.getTasksWithCompletionHandler &#123; dataTasks, uploadTasks, downloadTasks in        dataTasks.forEach &#123; $0.cancel() &#125;        uploadTasks.forEach &#123; $0.cancel() &#125;        downloadTasks.forEach &#123; $0.cancel() &#125;    &#125;        WTLoginProvider.manager.session.getTasksWithCompletionHandler &#123; dataTasks, uploadTasks, downloadTasks in        dataTasks.forEach &#123; $0.cancel() &#125;        uploadTasks.forEach &#123; $0.cancel() &#125;        downloadTasks.forEach &#123; $0.cancel() &#125;    &#125;    …… &#125;public func endpointMapping&lt;Target: TargetType&gt;(target: Target) -&gt; Endpoint &#123;    WTDLog(&quot;请求连接：\\(target.baseURL)\\(target.path) \\n方法：\\(target.method)\\n参数：\\(String(describing: target.task.self)) &quot;)    return MoyaProvider.defaultEndpointMapping(for: target)&#125;final class RequestAlertPlugin: PluginType &#123;        func prepare(_ request: URLRequest, target: TargetType) -&gt; URLRequest &#123;        return request    &#125;        func willSend(_ request: RequestType, target: TargetType) &#123;        //实现发送请求前需要做的事情    &#125;        public func didReceive(_ result: Result&lt;Response, MoyaError&gt;, target: TargetType) &#123;        switch result &#123;        case .success(let response):            guard response.statusCode == 200 else &#123;                if response.statusCode == 401 &#123;                    if isJumpLogin == false &#123;                        cancelAllRequest()                        // 退出登录                        if let nvc = (WTNavigationManger.Nav as? WTMainViewController) &#123;                            nvc.login()                        &#125;                    &#125;                &#125;                return            &#125;            var json = try? JSON(data: response.data)            WTDLog(&quot;请求状态码\\(json?[&quot;status&quot;] ?? &quot;&quot;)&quot;)                        guard let codeString = json?[&quot;status&quot;] else &#123;return&#125;             if codeString == 401 &#123;// 退出登录                if isJumpLogin == false &#123;                    cancelAllRequest()                    if let nvc = (WTNavigationManger.Nav as? WTMainViewController) &#123;                        nvc.login()                    &#125;                &#125;                break            &#125;        case .failure(let error):            WTDLog(error)            let myAppdelegate = UIApplication.shared.delegate as! AppDelegate            myAppdelegate.listenNetwork()            break        &#125;    &#125;&#125;struct AuthPlugin: PluginType &#123;    let token: String&#125;enum ApiManager &#123;&#125;extension ApiManager: TargetType &#123;    var headers: [String : String]? &#123;        var dict = [&quot;ColaLanguage&quot;: (&quot;common.isChinese&quot;.L() == &quot;YES&quot;) ? &quot;CN&quot; : &quot;EN&quot;]        if let authToken =  WTLoginInfoManger.shareDataSingle.model?.accessToken &#123;            dict[&quot;Authorization&quot;] = authToken        &#125;        return dict    &#125;        var baseURL: URL &#123;        return URL.init(string: AppURLHOST.MyPublicBaseURL)!    &#125;        var path: String &#123;        return &quot;&quot;    &#125;        var method: Moya.Method &#123;        return .get    &#125;        var task: Task &#123;        return .requestPlain    &#125;        var validate: Bool &#123;        return false    &#125;    var sampleData: Data &#123;        return &quot;&quot;.data(using: String.Encoding.utf8)!    &#125;&#125;/// 数据 转 模型extension ObservableType where E == Response &#123;    public func mapHandyJsonModel&lt;T: HandyJSON&gt;(_ type: T.Type) -&gt; Observable&lt;T&gt; &#123;        return flatMap &#123; response -&gt; Observable&lt;T&gt; in            return Observable.just(response.mapHandyJsonModel(T.self))        &#125;    &#125;&#125;/// 数据 转 模型extension Response &#123;    func mapHandyJsonModel&lt;T: HandyJSON&gt;(_ type: T.Type) -&gt; T &#123;        let jsonString = String.init(data: data, encoding: .utf8)        if let modelT = JSONDeserializer&lt;T&gt;.deserializeFrom(json: jsonString) &#123;            return modelT        &#125;        return JSONDeserializer&lt;T&gt;.deserializeFrom(json: &quot;&#123;\\&quot;msg\\&quot;:\\&quot;\\(&quot;common.try&quot;.L())\\&quot;&#125;&quot;)!    &#125;&#125;/// 自定义插件public final class NetworkLoadingPlugin: PluginType &#123;    public func willSend(_ request: RequestType, target: TargetType) &#123;    &#125;    public func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) &#123;    &#125;&#125;\n模式Target -&gt; Endpoint -&gt; Request\n\n\nMoya虽然是基于Alamofire的但是我们在代码中却不会和Alamofire打交道，它是通过枚举来管理API的。我在项目中定义来一个API基类，然后为每一个模块定义了一个API管理类。\n\nenum HomeApiManager &#123;    case getBanner // 获取轮播    case getAnnouncement(per_page: String) // 获取公告&#125;\n\n对于请求类型的改变和对于URL的改变也是通过枚举\nvar method: Moya.Method &#123;        switch self &#123;        case .orderCreate:            return .post        case .orderCancelById, .orderCancelByPair:            return .delete        default:            return .get        &#125;    &#125;var path: String &#123;        switch self &#123;        case .getKline:            return &quot;/api/kline&quot;        case .transGetByID(let orderId):            return &quot;/api/\\(orderId)&quot;        &#125;    &#125;\n请求任务\nvar task: Task &#123;    switch self &#123;    case .securityPostGoogleAuth(let tokenKey, let oldGoogleCode, let googleCode, let captcha):        return .requestParameters(parameters: [&quot;captcha&quot;: captcha], encoding: JSONEncoding.default) // post请求    case .getReward(let type, let cursor, let limit):        return .requestParameters(parameters: [&quot;type&quot;: type], encoding: URLEncoding.default) // 其它请求    case .uploadImage(let imageArry):        let formDataAry:NSMutableArray = NSMutableArray()        for (index,image) in imageArry.enumerated() &#123;            //图片转成Data            let data:Data = image.jpegData(compressionQuality: 0.7)!            //根据当前时间设置图片上传时候的名字            var dateStr: String = &quot;yyyy-MM-dd-HH:mm:ss&quot;.timeStampToString(timeStamp: Date().timeIntervalSince1970)            //别忘记这里给名字加上图片的后缀哦            dateStr = dateStr.appendingFormat(&quot;-%i.jpg&quot;, index)            let formData = MultipartFormData(provider: .data(data), name: &quot;file\\(index)&quot;, fileName: dateStr, mimeType: &quot;image/jpeg&quot;)            formDataAry.add(formData)        &#125;        return .uploadCompositeMultipart(formDataAry as! [MultipartFormData], urlParameters: [            :])            default:        return .requestPlain    &#125;&#125;\n插件机制\nMoya的另一个强大的功能就是它的插件机制，提供了两个接口，willSendRequest 和 didReceiveResponse，它可以在请求前和请求后做一些额外的操作而和主功能是解耦的，比如可以在请求前开始加载动画请求结束后移除加载动画，还可以自定义插件。\n\nfinal class RequestAlertPlugin: PluginType &#123;    func prepare(_ request: URLRequest, target: TargetType) -&gt; URLRequest &#123;        return request    &#125;    func willSend(_ request: RequestType, target: TargetType) &#123;        现发送请求前需要做的事情        if target.headers?[&quot;isHiddentLoading&quot;] != &quot;true&quot; &#123;            currentView?.addSubview(activityIndicatorView)            activityIndicatorView.center = currentView!.center            activityIndicatorView.startAnimating()        &#125;    &#125;    public func didReceive(_ result: Result&lt;Response, MoyaError&gt;, target: TargetType) &#123;        if activityIndicatorView.isAnimating &#123;            activityIndicatorView.stopAnimating()            activityIndicatorView.removeFromSuperview()        &#125;    &#125;&#125;/// 自定义插件public final class NetworkLoadingPlugin: PluginType &#123;    public func willSend(_ request: RequestType, target: TargetType) &#123;    &#125;    public func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) &#123;    &#125;&#125;\n\nMoya默认有4个插件\n\nAccessTokenPlugin    &#x2F;&#x2F; 管理AccessToken的插件\n\nCredentialsPlugin       &#x2F;&#x2F; 管理认证的插件\n\nNetworkActivityPlugin &#x2F;&#x2F; 管理网络状态的插件\n\nNetworkLoggerPlugin &#x2F;&#x2F; 管理网络log的插件\n\n\n\nRxSwift\n这里的RxSwift不是完整的RxSwift，而是为Moya定制的一个扩展(pod ‘Moya&#x2F;RxSwift’)在数据请求回来后进行处理。\n\nrequest()  传入API\n\nasObservable() 是Moya为RxSwift提供的扩展方法，返回可监听序列\n\nmapHandyJsonModel() 也是Moya RxSwift的扩展方法进行自定义的，可以把返回的数据解析成model\n\nsubscribe() 是对处理过的 Observable 订阅一个 onNext 的观察者，一旦得到JSON格式的数据，就会经行相应的处理\n\ndisposed() 是RxSwift的一个自动内存处理机制，类似ARC，会自动处理不需要的对象\n\n\n\n/// 数据 转 模型extension ObservableType where E == Response &#123;    public func mapHandyJsonModel&lt;T: HandyJSON&gt;(_ type: T.Type) -&gt; Observable&lt;T&gt; &#123;        return flatMap &#123; response -&gt; Observable&lt;T&gt; in            return Observable.just(response.mapHandyJsonModel(T.self))        &#125;    &#125;&#125;/// 数据 转 模型extension Response &#123;    func mapHandyJsonModel&lt;T: HandyJSON&gt;(_ type: T.Type) -&gt; T &#123;        let jsonString = String.init(data: data, encoding: .utf8)        if let modelT = JSONDeserializer&lt;T&gt;.deserializeFrom(json: jsonString) &#123;            return modelT        &#125;        return JSONDeserializer&lt;T&gt;.deserializeFrom(json: &quot;&#123;\\&quot;msg\\&quot;:\\&quot;\\(&quot;common.try&quot;.L())\\&quot;&#125;&quot;)!    &#125;&#125;extension WTApiManager &#123;    class func NetExchangeRequest&lt;T: BaseModel&gt;(disposeBag: DisposeBag,type: ExchangeApiManager, model: T.Type, isBackFail: Bool = false, Success:@escaping (T)-&gt;(), Error: @escaping ()-&gt;()) &#123;        WTExchangeProvider.rx.request(type)            .asObservable()            .mapHandyJsonModel(model)            .subscribe &#123; (event) in                switch event &#123;                case let .next(data):                    if isBackFail &#123;                        Success(data)                        break                    &#125;                    guard data.status == 200 else &#123;                        WTProgressHUD.show(error: data.message ?? &quot;common.try&quot;.L(), toView: nil)                        Error()                        break                    &#125;                    Success(data)                    break                case let .error(error):                    WTDLog(error)                    Error()                    break                default:                    break                &#125;            &#125;.disposed(by: disposeBag)    &#125;&#125;\n\nHandyJSONclass BaseModel: HandyJSON &#123;    var status: Int = 0    var message: String? = nil // 服务端返回提示    required init()&#123;&#125;&#125;class WTBaseModel&lt;T: HandyJSON&gt;: BaseModel &#123;    var data: T? // 具体的data的格式和业务相关，故用泛型定义&#125;struct WTCurrencyBalanceModel: HandyJSON &#123;    var coinCode: String = &quot;&quot;    let balanceAvailable: Double = 0.0    let balanceFrozen: Double = 0.0    let worth: Double = 0.0&#125;// 网络请求 传入对应modelWTApiManager.NetOtherRequest(disposeBag: disposeBag, type: .getMarketsPrice, model: WTBaseModel&lt;WTRateModel&gt;, Success: &#123;(model) in&#125;) &#123;&#125;\n\n以上就是我在项目中使用Moya+HandyJSON+RxSwift的方法，如果有错误或者不足之处还望指正，谢谢\n","categories":["swift"],"tags":["“swift”","“网络请求”","“Moya”","“HandyJSON”","“RxSwift”"]},{"title":"项目剖析04-swift 网络请求Moya+Alamofire(HTTPS)证书验证","url":"/2024/03/05/%E9%A1%B9%E7%9B%AE%E5%89%96%E6%9E%9004-swift-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82Moya-Alamofire-HTTPS-%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81/","content":"SSL证书验证一种加强App 和 Server 间通讯安全的方法。主要目标是确保 App 仅与预先验证的 Server 建立安全连接，防止中间人攻击（Man-in-the-Middle，MitM）等安全风险。一般常用的有两种方式进行验证，Certificate Pinning和Public Key Pinning。\n\nAlamofire5.0 以后将证书验证类放于ServerTrustEvaluation这个类里面。一共有6种验证策略：\n\nDefaultTrustEvaluator - （默认验证策略）只要是合法证书就能通过验证。\n\nRevocationTrustEvaluator（验证注销策略）对注销证书做的一种额外设置，Alamofire从iOS10.1才开始支持吊销证书的策略。\n\nPinnedCertificatesTrustEvaluator（证书验证策略）app端会对服务器端返回的证书和本地保存的证书中的全部内容进行校验需要全部正确，此验证策略还可以接受自签名证书，安全性相对较高，此方法较为固定，如果 Server 更新证书，App 需要定期更新并重新上架。\n\nPublicKeysTrustEvaluator（公钥验证策略）app端只会对服务器返回的证书和本地保存的证书中的 PublicKey(公钥)进行校验，所以当证书需要更新时，只需确保公钥保持不变，不需要更新App。\n\nCompositeTrustEvaluator（自定义组合验证策略）以上多种策略组合一起，只有在所有数组中值都成功时才成功。\n\nDisabledTrustEvalutor（不验验证策略）无条件信任，所有都可以通过验证。正式环境不建议用此策略，多用于测试。\n\n\n\n我们用的是PublicKeysTrustEvaluator（公钥验证策略）\n\n\n后台提供证书，将正式放在项目目录中。\n\n\n\n获取本地证书，提取证书的公钥（获取公钥key数组）。证书后缀名一般有：.cer、.crt、.der等，我项目中用的cer，证书链必须包含一个固定的公钥。\n\nstruct WTCertificates &#123;    static let rootCA = WTCertificates.certificate( )    static func certificate() -&gt; [SecKey] &#123;        var publicKeyArray:[SecKey] = []        for resource in [&quot;xxx&quot;, &quot;xxxx&quot;, &quot;xxxxx&quot;] &#123;// 本地证书名称            if let filePath = Bundle.main.path(forResource: resource, ofType: &quot;cer&quot;), let data = try? Data(contentsOf: URL(fileURLWithPath: filePath)) as CFData, let certificate = SecCertificateCreateWithData(nil, data),let publicKey = certificate.af.publicKey &#123;                publicKeyArray.append(publicKey)            &#125;        &#125;        return publicKeyArray    &#125;&#125;\n\n给Session添加策略（接受质询）\n\nvar requestManagerSession: Session = &#123;    if WTCertificates.rootCA.count &gt; 0, verifyCert &#123;        let certificates: [SecKey] = WTCertificates.rootCA        let trustPolicy = PublicKeysTrustEvaluator(keys: certificates, performDefaultValidation: false, validateHost: false)        let manager = ServerTrustManager(evaluators: [            &quot;xxx.xxx.com&quot;: trustPolicy,            &quot;xx.xx.jftplus.com&quot;: trustPolicy,            &quot;xxx.xx.com&quot;: trustPolicy])// base url 如何域名过多，可以子类化 ServerTrustManager，并用自己的自定义实现重写 serverTrustEvaluator(forHost:) 方法        let configuration = URLSessionConfiguration.af.default        return Session(configuration: configuration, serverTrustManager: manager)    &#125;    return MoyaProvider&lt;ApiManager&gt;.defaultAlamofireSession()&#125;()\n\n\n在Moya中添加requestManagerSession\n\nvar JKOtherApiManagerProvider = MoyaProvider&lt;JKOtherApiManager&gt;(endpointClosure: endpointMapping, requestClosure: requestTimeoutClosure, session:requestManagerSession, plugins:[RequestAlertPlugin(), networkPlugin])\nOC HTTPS 证书配置验证//1 将证书拖进项目//2 获取证书路径NSString *certPath = [[NSBundle mainBundle] pathForResource: @&quot;cetus&quot; ofType:@&quot;cer&quot;];//3 获取证书dataNSData *certData = [NSData dataWithContentsOfFile:certPath];//4 创建AFN 中的securityPolicyAFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey withPinnedCertificates:[[NSSet alloc] initWithObjects:certData,nil]];//5 这里就可以添加多个server证书NSSet *dataSet = [[NSSet alloc]initWithObjects:certData, nil];//6 绑定证书（不止一个证书）[securityPolicy setPinnedCertificates:dataSet];//7 是否允许无效证书securityPolicy.allowInvalidCertificates = YES;//8 是否需要验证域名securityPolicy.validatesDomainName = YES;uploadManager.securityPolicy = securityPolicy;\n\n我们后台给的证书格式后缀是.pem，以下是用OpenSSL命令将.pem证书转换为cer格式证书方法\n\n\n打开命令行工具，进入存放xxx.pem证书的目录\n输入以下命令，将.pem证书转换为cer格式openssl x509 -in xxx.pem -inform PEM -out xxx.cer -outform DER\n执行完毕后，您将在当前目录下看到生成的xxx.cer文件\n\n\n注意：转换后的cer证书文件只包含公钥，不包含私钥信息\n\n","categories":["swift"],"tags":["“swift”","“证书验证”","“SSL”"]},{"title":"项目总结-位置实时共享","url":"/2016/11/17/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-%E4%BD%8D%E7%BD%AE%E5%AE%9E%E6%97%B6%E5%85%B1%E4%BA%AB/","content":"\n从北京回来到今天已经整整三个月了，三个月没有更新简书了。回来找了一家新的公司上班，正好今天新项目打包测试了，找了点时间来总结一下最近项目中遇到的一些问题与心得。今天主要分享位置实时共享，其实之前也有时间，因为在新的公司很少加班。但是自己太懒了，所以……。\n\n谈谈新公司  \n\n进入公司才发现公司有个iOS大神和我是一个大学的 还是一个系的 还是同一级的，还有两个Android与我是一个专业的，这个行业真的小啊😄。公司不大，老板是个美籍华人（这应该是我们加班少的原因吧）。     \n\n谈谈项目    \n\n项目内容保密（签了协议的）……，还是谈技术吧。1&gt;即时通讯：我们用的是环信的，因为这不是主要的功能，使用就直接用的是环信的UI，就是官方demo里面的EaseUI，导入SDK就不用说了，我主要分享一下我们在里面添加的一个新的功能：实时位置共享 我们将这个功能添加在群聊里面的。主要逻辑：是通过环信群聊的透传消息实现的用的是百度地图。\n\n通过百度地图定位 将自己的位置的经纬度放在透传消息的扩展信息中传出去\n// 更新发送- (void)sendCmdMessageWithType:(NSString *)type &#123;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;        EMCmdMessageBody *body = [[EMCmdMessageBody alloc] initWithAction:@&quot;shareLocation&quot;];        _currentUserId = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;eid&quot;];        NSDictionary *ext = @&#123;@&quot;latitude&quot;:@(_userStartLocation.location.coordinate.latitude),@&quot;longitude&quot;:@(_userStartLocation.location.coordinate.longitude),@&quot;type&quot;:type,_currentUserId:[[NSUserDefaults standardUserDefaults] objectForKey:@&quot;user_nickname&quot;]&#125;;                EMMessage *message = [[EMMessage alloc] initWithConversationID:self.conversationID                                                                  from:_currentUserId                                                                    to:self.conversationID                                                                  body:body                                                                   ext:ext];        message.chatType = EMChatTypeGroupChat;        [[EMClient sharedClient].chatManager sendMessage:message progress:nil completion:^(EMMessage *message, EMError *error) &#123;            if (error) &#123;                [CTHUD showText:@&quot;位置更新失败&quot;];                // 去请求token            &#125;        &#125;];    &#125;);&#125;\n然后在解析透彻信息的解析位置信息\n// 收到解析- (void)didReceiveCmdMessages:(NSArray *)aCmdMessages &#123;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;        for (EMMessage *cmdMessage in aCmdMessages) &#123;            EMCmdMessageBody *body = (EMCmdMessageBody *)cmdMessage.body;            // 判断是否是位置共享消息            if ([body.action isEqualToString:@&quot;shareLocation&quot;]) &#123;                CLLocationCoordinate2D coordinate;                coordinate.latitude = [[cmdMessage.ext objectForKey:@&quot;latitude&quot;] doubleValue];                coordinate.longitude = [[cmdMessage.ext objectForKey:@&quot;longitude&quot;] doubleValue];                NSString *nickName = [cmdMessage.ext objectForKey:cmdMessage.from];                if ([[cmdMessage.ext objectForKey:@&quot;type&quot;] isEqualToString:@&quot;update&quot;]) &#123;                    dispatch_async(dispatch_get_main_queue(), ^&#123;                        [self updateOtherAnnotationWithLocation:coordinate UserNickName:nickName];                    &#125;);                &#125;else if ([[cmdMessage.ext objectForKey:@&quot;type&quot;] isEqualToString:@&quot;remove&quot;]) &#123;                    dispatch_async(dispatch_get_main_queue(), ^&#123;                        [self removeOtherAnnotationWithUserNickName:nickName];                    &#125;);                &#125;else if ([[cmdMessage.ext objectForKey:@&quot;type&quot;] isEqualToString:@&quot;join&quot;]) &#123;                    dispatch_async(dispatch_get_main_queue(), ^&#123;                        [self addMyAnnotationWithLocation:coordinate UserNickName:nickName];                        [self sendCmdMessageWithType:@&quot;feedback&quot;];                    &#125;);                &#125;else if ([[cmdMessage.ext objectForKey:@&quot;type&quot;] isEqualToString:@&quot;feedback&quot;]) &#123;                    dispatch_async(dispatch_get_main_queue(), ^&#123;                        [self addMyAnnotationWithLocation:coordinate UserNickName:nickName];                    &#125;);                &#125;            &#125;        &#125;    &#125;);&#125;\n将所有收到的透传消的位置信息标识在地图上\n// 添加新的用户标注- (void)addMyAnnotationWithLocation:(CLLocationCoordinate2D)coordinate UserNickName:(NSString *)nickName&#123;    BMKPointAnnotation *annotation = [[BMKPointAnnotation alloc]init];    annotation.coordinate = coordinate;    annotation.title = nickName;    [_mapView addAnnotation:annotation];    [_mapView selectAnnotation:annotation animated:YES];    [_otherUserAnnotation addObject:annotation];    [_otherUserNickName addObject:nickName];    [_mapView showAnnotations:_otherUserAnnotation animated:YES];    [_mapView setCenterCoordinate:coordinate animated:YES];    while (!_mapView.zoomOut) &#123;    &#125;&#125;\n\n还需要通过传递者的传递的类型定该位置是新加入用户还是已经存在的用户\nif ([[cmdMessage.ext objectForKey:@&quot;type&quot;] isEqualToString:@&quot;update&quot;]) &#123;                    dispatch_async(dispatch_get_main_queue(), ^&#123;                        [self updateOtherAnnotationWithLocation:coordinate UserNickName:nickName];                    &#125;);                &#125;else if ([[cmdMessage.ext objectForKey:@&quot;type&quot;] isEqualToString:@&quot;remove&quot;]) &#123;                    dispatch_async(dispatch_get_main_queue(), ^&#123;                        [self removeOtherAnnotationWithUserNickName:nickName];                    &#125;);                &#125;else if ([[cmdMessage.ext objectForKey:@&quot;type&quot;] isEqualToString:@&quot;join&quot;]) &#123;                    dispatch_async(dispatch_get_main_queue(), ^&#123;                        [self addMyAnnotationWithLocation:coordinate UserNickName:nickName];                        [self sendCmdMessageWithType:@&quot;feedback&quot;];                    &#125;);                &#125;else if ([[cmdMessage.ext objectForKey:@&quot;type&quot;] isEqualToString:@&quot;feedback&quot;]) &#123;                    dispatch_async(dispatch_get_main_queue(), ^&#123;                        [self addMyAnnotationWithLocation:coordinate UserNickName:nickName];                    &#125;);                &#125;\n\n新用户需要添加大头针，已经存在的用户只需要更新位置\n// 更新用户标注- (void)updateOtherAnnotationWithLocation:(CLLocationCoordinate2D)coordinate UserNickName:(NSString *)nickName&#123;    for (BMKPointAnnotation *annotation in _otherUserAnnotation) &#123;        if ([annotation.title isEqualToString:nickName]) &#123;            annotation.coordinate = coordinate;        &#125;    &#125;&#125;\n\n通过百度地图获得自己移动的距离\nBMKMapPoint point1 = BMKMapPointForCoordinate(CLLocationCoordinate2DMake(_userStartLocation.location.coordinate.latitude,_userStartLocation.location.coordinate.latitude));BMKMapPoint point2 = BMKMapPointForCoordinate(CLLocationCoordinate2DMake(userLocation.location.coordinate.latitude,userLocation.location.coordinate.latitude)); CLLocationDistance distance = BMKMetersBetweenMapPoints(point1,point2); \n\n自己定义一个移动的精度，我们当时定的移动距离大于20米（distance&gt;20）就发送一次位置更新。最后当需要离开位置共享是也需要再发送一次信息，透传解析出，然后移除标识\n\n// 删除用户标注- (void)removeOtherAnnotationWithUserNickName:(NSString *)nickName&#123;    for (BMKPointAnnotation *annotation in _otherUserAnnotation) &#123;        if ([annotation.title isEqualToString:nickName]) &#123;            [_otherUserAnnotation removeObject:annotation];            [_otherUserNickName removeObject:nickName];            [_mapView removeAnnotation:annotation];        &#125;    &#125;&#125;\n\n结束语\n\n实时共享 其实与群聊差不多，就是我的位置移动距离达到了精度要求，我就发送一次群消息，让每一个参加共享的人都知道，然后在自己的地图上更新一次。以上就是我们的位置实时共享的逻辑与部分代码，欢迎各位的指正，谢谢。\n\n","categories":["iOS"],"tags":["“iOS”","“百度地图”","“位置实时共享”"]},{"url":"/2025/06/09/configs/sorts/","content":"{\"\":[\"widget-advanced.md\",\"hello-world.md\",\"images\",\"title\"],\"__positions\":{\"images\":3,\"widget-advanced.md\":1,\"hello-world.md\":2,\"title\":4},\"__raw_positions\":{\"images\":3,\"widget-advanced.md\":1,\"hello-world.md\":2,\"title\":4}}"}]