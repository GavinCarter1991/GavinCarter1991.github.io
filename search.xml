<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Widget进阶</title>
    <url>/2025/06/07/Widget%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="1-Widget-介绍1"><a href="#1-Widget-介绍1" class="headerlink" title="1.Widget 介绍1"></a>1.Widget 介绍1</h2><blockquote>
<p>Everything is a widget 这是你学习flutter会听到的最多的一句话。因为在Flutter中几乎所有的对象都是一个 widget，在flutter中UI的构建和事件的处理基本都是通过widget的组合及嵌套来完成的。在iOS中我们经常提及的“组件”、“控件”在flutter中就是widget，当然widget的范围比之更加广泛。如：手势检测GestureDetector、主题Theme和动画容器AnimatedContainer等也是widget。</p>
</blockquote>
<p><strong>Flutter默认支持的两种设计风格：</strong></p>
<blockquote>
<p><strong>1.Material components Design：</strong> 谷歌（android）的UI风格，主要为 Android 设计，但也支持跨平台使用。</p>
</blockquote>
<blockquote>
<p><strong>2.Cupertino Design：</strong> 苹果（iOS）的UI风格，模仿苹果原生 UIKit 风格。高度还原 iOS 原生体验，适合需要与苹果生态一致的应用。</p>
</blockquote>
<h2 id="2-Widget-分类"><a href="#2-Widget-分类" class="headerlink" title="2.Widget 分类"></a>2.Widget 分类</h2><p><em><strong>1.按状态管理</strong></em></p>
<h6 id="一、StatelessWidget："><a href="#一、StatelessWidget：" class="headerlink" title="一、StatelessWidget："></a>一、StatelessWidget：</h6><p>无状态组件，通过 build 方法返回静态 UI。不可变，属性（final）在创建后无法修改，适用于不需要内部状态变化的场景（如文本显示、图标），不依赖用户交互或数据变化的 UI 部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class IconTextButton extends StatelessWidget &#123;</span><br><span class="line">  final String iconName;</span><br><span class="line">  final String label;</span><br><span class="line">  final VoidCallback onPressed;</span><br><span class="line"></span><br><span class="line">  const IconTextButton(&#123;</span><br><span class="line">    super.key,</span><br><span class="line">    required this.iconName,</span><br><span class="line">    required this.label,</span><br><span class="line">    required this.onPressed,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return GestureDetector(</span><br><span class="line">      onTap: onPressed,</span><br><span class="line">      child: Column(</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Image.asset(</span><br><span class="line">            &quot;assets/images/$iconName.png&quot;,</span><br><span class="line">            width: 40,</span><br><span class="line">            height: 40,</span><br><span class="line">          ),</span><br><span class="line">          const SizedBox(</span><br><span class="line">            height: 10,</span><br><span class="line">          ), // 图标</span><br><span class="line">          Text(</span><br><span class="line">            label,</span><br><span class="line">            style: const TextStyle(color: ColorConstant.color33, fontSize: 10),</span><br><span class="line">          ), // 文字</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="二、StatefulWidget："><a href="#二、StatefulWidget：" class="headerlink" title="二、StatefulWidget："></a>二、StatefulWidget：</h6><p>有状态组件，通过 State 对象管理动态数据。当状态变化时调用 setState 触发 UI 更新，需要用户交互（如按钮点击、表单输入）和依赖实时数据变化（如计数器、动态列表）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 上下滚动的消息轮播</span><br><span class="line">class MarqueeWidget extends StatefulWidget &#123;</span><br><span class="line">  /// 子视图数量</span><br><span class="line">  final int count;</span><br><span class="line"></span><br><span class="line">  ///子视图构建器</span><br><span class="line">  final IndexedWidgetBuilder itemBuilder;</span><br><span class="line"></span><br><span class="line">  ///轮播的时间间隔</span><br><span class="line">  final int loopSeconds;</span><br><span class="line"></span><br><span class="line">  const MarqueeWidget(&#123;</span><br><span class="line">    super.key,</span><br><span class="line">    required this.count,</span><br><span class="line">    required this.itemBuilder,</span><br><span class="line">    this.loopSeconds = 5,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MarqueeWidgetState createState() =&gt; _MarqueeWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MarqueeWidgetState extends State&lt;MarqueeWidget&gt; &#123;</span><br><span class="line">  late PageController _controller;</span><br><span class="line">  late Timer _timer;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    _controller = PageController();</span><br><span class="line">    _timer = Timer.periodic(Duration(seconds: widget.loopSeconds), (timer) &#123;</span><br><span class="line">      if (_controller.page != null) &#123;</span><br><span class="line">        // 如果当前位于最后一页，则直接跳转到第一页，两者内容相同，跳转时视觉上无感知</span><br><span class="line">        if (_controller.page!.round() &gt;= widget.count) &#123;</span><br><span class="line">          _controller.jumpToPage(0);</span><br><span class="line">        &#125;</span><br><span class="line">        _controller.nextPage(</span><br><span class="line">            duration: const Duration(seconds: 1), curve: Curves.linear);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return PageView.builder(</span><br><span class="line">      scrollDirection: Axis.vertical,</span><br><span class="line">      controller: _controller,</span><br><span class="line">      itemBuilder: (buildContext, index) &#123;</span><br><span class="line">        if (index &lt; widget.count) &#123;</span><br><span class="line">          return widget.itemBuilder(buildContext, index);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return widget.itemBuilder(buildContext, 0);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      itemCount: widget.count + 1,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    super.dispose();</span><br><span class="line">    _controller.dispose();</span><br><span class="line">    _timer.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><em><strong>2.按功能分类</strong></em></p>
<blockquote>
<p><strong>1.布局类 Widget：</strong> 控制子 Widget 的排列方式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Row/Column：水平/垂直排列子项（基于 Flexbox）。</span><br><span class="line">Stack：子 Widget 堆叠（类似 CSS 的绝对定位）。</span><br><span class="line">Expanded/Flexible：在 Row 或 Column 中分配剩余空间。</span><br><span class="line">Container：结合布局、装饰、边距等功能</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>2.基础组件 Widget：</strong> 构成 UI 的基本元素。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Text：显示文本。</span><br><span class="line">Image：加载本地或网络图片。</span><br><span class="line">Icon：显示图标（需引入 cupertino_icons 或自定义图标库）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>3.滚动类 Widget：</strong> 处理内容超出屏幕时的滚动行为。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见有：</span><br><span class="line">ListView：垂直/水平滚动列表。</span><br><span class="line">GridView：网格布局滚动视图。</span><br><span class="line">SingleChildScrollView：包裹单个可滚动子组件。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>4.交互类 Widget：</strong> 响应用户输入事件。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见有：</span><br><span class="line">ElevatedButton/TextButton：按钮交互。</span><br><span class="line">TextField：文本输入框。</span><br><span class="line">Checkbox/Switch：选择控件。</span><br><span class="line">GestureDetector：自定义手势检测（点击、长按、拖动）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>5.平台风格类 Widget：</strong> 适配不同操作系统的视觉风格。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Material Design：MaterialApp、AppBar、FloatingActionButton。</span><br><span class="line">Cupertino（iOS 风格）：CupertinoApp、CupertinoNavigationBar、CupertinoPicker。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>6.动画类 Widget：</strong> 实现动态视觉效果。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见有：</span><br><span class="line">AnimatedContainer：自动过渡的容器（大小、颜色等属性变化）。</span><br><span class="line">Hero：页面切换共享元素的过渡动画。</span><br><span class="line">AnimatedBuilder：自定义复杂动画。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>7. 导航与路由类 Widget：</strong> 管理页面跳转和导航结构。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见有：</span><br><span class="line">Navigator：管理页面堆栈（push/pop）。</span><br><span class="line">PageView：实现滑动切换页面。</span><br><span class="line">BottomNavigationBar：底部导航栏。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过简单 Widget 组合实现复杂 UI（例如用 Row + Expanded 替代自定义布局）(优先组合而非继承)<br>局部状态使用 StatefulWidget<br>全局状态使用状态管理工具（如 Provider、Riverpod）<br>对频繁更新的部分使用 const 构造函数<br>长列表使用 ListView.builder 懒加载</p>
</blockquote>
<h2 id="3-Widget-生命周期"><a href="#3-Widget-生命周期" class="headerlink" title="3.Widget 生命周期"></a>3.Widget 生命周期</h2><p><strong>StatelessWidget 的生命周期</strong></p>
<blockquote>
<p>StatelessWidget 仅有一个 build() 方法，无状态管理逻辑，其生命周期完全由父组件控制。</p>
</blockquote>
<p><strong>StatefulWidget主要生命周期方法</strong></p>
<blockquote>
<p>创建阶段<br>createState()</p>
</blockquote>
<blockquote>
<p>初始化阶段<br>initState()<br>didChangeDependencies()</p>
</blockquote>
<blockquote>
<p>更新阶段<br>didUpdateWidget(oldWidget)<br>build()</p>
</blockquote>
<blockquote>
<p>销毁阶段<br>deactivate()<br>dispose()</p>
</blockquote>
<p><img src="https://i-blog.csdnimg.cn/img_convert/a33469c55f94b5278f698d8605d8e0cc.webp?x-oss-process=image/format,png" alt="2025-05-22 18.38.22.png"><br><strong>1.createState()</strong><br>当 StatefulWidget 被插入 Widget 树时调用，而且只执行一次。</p>
<blockquote>
<p>主要用于创建与之关联的 State 对象（每个 Widget 对应一个 State 实例）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyWidget extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _MyWidgetState createState() =&gt; _MyWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2.initState()</strong><br>在State 对象创建后，首次调用 build() 之前触发该方法，而且只执行一次。</p>
<blockquote>
<p>主要用于初始化依赖数据（如订阅事件、加载本地配置）和 创建动画控制器（AnimationController）等需与 dispose() 配对的资源。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  super.initState();</span><br><span class="line">  _controller = AnimationController(vsync: this);</span><br><span class="line">  _fetchData(); // 初始化数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是：<br><code>必须调用 super.initState()。</code><br><code>在这里 View 并没有渲染，只是 StatefulWidget 被加载到渲染树里了。</code><br><code>避免在此处触发 setState（可能导致渲染未完成）。</code><br><code>StatefulWidget的 mount 的值变为了true（调用dispose()才会变为 false）。</code></p>
<p><strong>3.didChangeDependencies()</strong><br>initState() 后立即调用didChangeDependencies()。<br>当 State 依赖的 InheritedWidget 发生变化时（如主题、本地化）也会调用didChangeDependencies()。</p>
<blockquote>
<p>主要用于处理依赖变化后的逻辑（如重新请求网络数据）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">void didChangeDependencies() &#123;</span><br><span class="line">  super.didChangeDependencies();</span><br><span class="line">  if (Provider.of&lt;Data&gt;(context).hasChanged) &#123;</span><br><span class="line">    _updateData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>4. didUpdateWidget(oldWidget)</strong><br>在父组件重建时，若新旧 Widget 的 runtimeType 和 key 相同触发didUpdateWidget（didUpdateWidget我们一般不会用到）。</p>
<blockquote>
<p>主要是：<br>对比新旧 Widget 的配置（如属性变化）。<br>根据变化调整状态（如重置动画、更新监听）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">void didUpdateWidget(MyWidget oldWidget) &#123;</span><br><span class="line">  super.didUpdateWidget(oldWidget);</span><br><span class="line">  if (oldWidget.color != widget.color) &#123;</span><br><span class="line">    _updateColor(); // 颜色变化时执行逻辑</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>5. build()</strong><br>初始化后、依赖变化后、setState() 调用后调用build()。<br>父组件或祖先组件触发重建时调用build()。</p>
<blockquote>
<p>主要是根据当前状态构建 UI（不要在这里做除了创建 Widget 之外的操作）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Container(</span><br><span class="line">    color: widget.color,</span><br><span class="line">    child: Text(&#x27;Count: $_count&#x27;),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是：<br><code>必须返回一个 Widget</code><br><code>避免在此处修改状态或执行耗时操作</code></p>
<p><strong>6. deactivate()</strong><br>当 State 从树中暂时移除（如页面切换、组件被移除）触发deactivate()。</p>
<blockquote>
<p>清理临时资源或保存临时状态.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">需要注意的是：</span><br><span class="line">`可能被重新插入树中（如页面返回时），需与 dispose() 区分`</span><br><span class="line"></span><br><span class="line">**7. dispose()**</span><br><span class="line">State 被永久移除时调用dispose()。</span><br><span class="line">&gt;释放资源（如取消网络请求、销毁动画控制器）</span><br></pre></td></tr></table></figure>
<p>@override<br>void dispose() {<br>  _controller.dispose(); &#x2F;&#x2F; 销毁动画控制器<br>  _subscription.cancel(); &#x2F;&#x2F; 取消事件订阅<br>  super.dispose();<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要注意的是：</span><br><span class="line">`如果在 dispose() 中未释放资源（如动画控制器、Stream 订阅）可能造成内存泄漏`</span><br><span class="line">`如果在 dispose() 后调用 setState 会导致异常`</span><br><span class="line"></span><br><span class="line">## 4.Widget 的渲染</span><br><span class="line">**渲染流程：**</span><br><span class="line">Flutter 的渲染系统基于三棵核心树结构，通过高度优化的管线（Pipeline）实现高效的 UI 更新。</span><br><span class="line">&gt;**Widget 重建 → Diff 新旧 Widget 树 → 更新 Element 树 → 更新 RenderObject 树 → 触发 Layer 合成 → 屏幕刷新**</span><br><span class="line"></span><br><span class="line">**1.Widget 树的构建：**</span><br><span class="line">&gt;描述 UI 的不可变配置，由开发者创建，频繁重建，需轻量化。</span><br><span class="line">开发者编写的 Widget 代码被转化为嵌套的 Widget 树（应用的入口是根Widget，一般是MaterialApp或CupertinoApp。根Widget会递归地构建其子Widget，形成一棵树。）。</span><br><span class="line">具有不可变性，每次重建生成全新的 Widget 树，但通过 Diff 算法可以优化实际更新范围。</span><br><span class="line"></span><br><span class="line">**2. Element 树的 Diff 与更新**</span><br><span class="line">&gt;根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 Element 类。</span><br><span class="line">Element 是 Widget 的实例化对象，负责管理 状态（State） 和 子节点引用。</span><br><span class="line">每个Widget都会有一个对应的Element对象，用于管理其生命周期。</span><br><span class="line"></span><br><span class="line">&gt;Diff 算法：Flutter 对比新旧 Widget 树，仅更新变化的 Element 和 RenderObject，类似 React 的虚拟 DOM。</span><br><span class="line">&gt;当 Widget 树重建时，Flutter 通过 Diff 算法 对比新旧 Widget 树，决定 Element 树的更新策略</span><br><span class="line">Reuse：若新旧 Widget 的 runtimeType 和 key 相同，复用现有 Element。</span><br><span class="line">Update：更新 Element 的配置（调用 Element.update(newWidget)）。</span><br><span class="line">Replace：类型或 Key 不同时，销毁旧 Element，创建新 Element。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 旧 Widget 树<br>Container(color: Colors.red)</p>
<p>&#x2F;&#x2F; 新 Widget 树<br>Container(color: Colors.blue)</p>
<p>&#x2F;&#x2F; Diff 结果：Container 类型相同且无 Key → 复用 Element，更新 RenderObject 颜色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; Element 更新逻辑<br>Element.updateChild()</p>
<p>Element updateChild(Element child, Widget newWidget, dynamic newSlot) {<br>  if (newWidget &#x3D;&#x3D; null) {<br>    &#x2F;&#x2F; 移除子节点<br>    return null;<br>  }<br>  if (child !&#x3D; null) {<br>    if (child.widget &#x3D;&#x3D; newWidget) {<br>      &#x2F;&#x2F; Widget 未变化 → 复用 Element<br>      return child;<br>    }<br>    if (Widget.canUpdate(child.widget, newWidget)) {<br>      &#x2F;&#x2F; 更新 Element 配置<br>      child.update(newWidget);<br>      return child;<br>    }<br>    &#x2F;&#x2F; 销毁旧 Element，创建新 Element<br>    deactivateChild(child);<br>  }<br>  return inflateWidget(newWidget, newSlot);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**3. RenderObject 树的更新**</span><br><span class="line"></span><br><span class="line">更新 RenderObject 树，计算布局和生成绘制指令。</span><br><span class="line">运行在 UI Thread。</span><br><span class="line"></span><br><span class="line">&gt;根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自RenderObject 类。</span><br><span class="line">每个 Element 对应一个 RenderObject（通过 Element.createRenderObject() 创建）。</span><br><span class="line"></span><br><span class="line">&gt;根据父 RenderObject 传递的 约束（Constraints），计算自身尺寸和位置。</span><br><span class="line">递归调用子节点的 layout() 方法（深度优先遍历）。</span><br><span class="line"></span><br><span class="line">**布局（Layout）核心方法：**</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; RenderObject 布局流程<br>RenderObject.layout()</p>
<p>void layout(Constraints constraints, { bool parentUsesSize &#x3D; false }) {<br>  _constraints &#x3D; constraints;<br>  if (_relayoutBoundary !&#x3D; this) {<br>    markNeedsLayout();<br>    return;<br>  }<br>  performLayout();  &#x2F;&#x2F; 1. 计算自身尺寸（调用 performLayout） 由子类实现具体布局逻辑<br>  _needsLayout &#x3D; false;<br>  markNeedsPaint(); &#x2F;&#x2F; 标记需要重绘<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;生成绘制指令（如形状、颜色、文本），写入 Layer（合成层）。</span><br><span class="line"></span><br><span class="line">**绘制（Paint）核心方法:**</span><br></pre></td></tr></table></figure>
<p>void paint(PaintingContext context, Offset offset) {<br>  &#x2F;&#x2F; 绘制逻辑，如画矩形<br>  context.canvas.drawRect(rect, paint);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**4. 合成与光栅化（Composition &amp; Rasterization）**</span><br><span class="line"></span><br><span class="line">生成 Layer 树并光栅化。</span><br><span class="line">运行在 Raster Thread（与 UI Thread 并行）</span><br><span class="line"></span><br><span class="line">&gt;根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 Layer 类。</span><br><span class="line">RenderObject 的绘制结果被组织为 Layer 树，每个 Layer 对应一个 GPU 纹理（Texture）。自此Layer 树生成。</span><br><span class="line">类型包括：PictureLayer（矢量绘制）、TextureLayer（图像纹理）、TransformLayer（变换效果）等。</span><br><span class="line"></span><br><span class="line">&gt;将 Layer 树中的绘制指令转换为 GPU 可识别的位图数据。</span><br><span class="line">通过 Skia 图形库（或 Impeller）完成，最终提交给 GPU 渲染。（完成光栅化（Raster Thread））。</span><br></pre></td></tr></table></figure>
<p>void paintChild(RenderObject child, Offset offset) {<br>  if (child.isRepaintBoundary) {<br>    &#x2F;&#x2F; 创建独立 Layer<br>    stopRecordingIfNeeded();<br>    child._layer &#x3D; OffsetLayer();<br>    appendLayer(child._layer);<br>  } else {<br>    child._paintWithContext(this, offset);<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**5. GPU 渲染与屏幕刷新**</span><br><span class="line">  </span><br><span class="line">&gt;**垂直同步（VSync）：**</span><br><span class="line">由系统定时触发的信号，控制帧率（如 60Hz → 16.6ms/帧）。</span><br><span class="line">Flutter 引擎在 VSync 信号到来时，提交光栅化后的帧数据到 GPU。</span><br><span class="line"></span><br><span class="line">&gt;**屏幕显示：**</span><br><span class="line">GPU 将帧数据写入帧缓冲区（Frame Buffer），屏幕硬件按刷新率读取并显示。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5.Widget 优化</span><br><span class="line"></span><br><span class="line">`高性能渲染 = 最小化 Widget Diff + 高效布局/绘制 + GPU 线程优化`</span><br><span class="line"></span><br><span class="line">&gt;Flutter 优化的本质是 减少无效计算 和 降低 GPU 负载</span><br><span class="line">一般围绕四个方向：</span><br><span class="line">1.最小化 Widget 树 Diff 范围</span><br><span class="line">2.减少布局（Layout）和绘制（Paint）计算</span><br><span class="line">3.优化 GPU 合成与光栅化（Rasterization）</span><br><span class="line">4.高效管理状态与资源</span><br><span class="line"></span><br><span class="line">&gt;**性能分析工具**</span><br><span class="line">Flutter DevTools：</span><br><span class="line">Performance 面板：分析 UI/Raster 线程的帧耗时。</span><br><span class="line">Layer 查看器：检测 Layer 合成是否合理。</span><br><span class="line">debugProfileBuildsEnabled：追踪 Widget 构建耗时</span><br><span class="line">调试标记：</span><br><span class="line">debugPrintMarkNeedsLayoutStacks：打印触发布局的堆栈信息。</span><br><span class="line">debugPaintLayerBordersEnabled：可视化 Layer 边界。</span><br><span class="line"></span><br><span class="line">**1.Widget 树 Diff 优化**</span><br><span class="line"></span><br><span class="line">&gt;**Diff 算法机制：** 当父组件更新时，Flutter 递归对比新旧 Widget 树，判断是否需要更新 Element 和 RenderObject。</span><br></pre></td></tr></table></figure>
<p>static bool canUpdate(Widget oldWidget, Widget newWidget) {<br>  return oldWidget.runtimeType &#x3D;&#x3D; newWidget.runtimeType<br>      &amp;&amp; oldWidget.key &#x3D;&#x3D; newWidget.key;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;**复用条件：** runtimeType 和 key 相同 → 复用 Element，仅更新配置。</span><br><span class="line">**替换条件：** 类型或 Key 不同 → 销毁旧 Element，创建新 Element。</span><br><span class="line"></span><br><span class="line">**优化策略：**</span><br><span class="line">**1.使用 const 构造函数：** const Widget 在多次重建中引用同一内存地址，Widget.canUpdate 直接返回 true，跳过 Diff 计算。</span><br></pre></td></tr></table></figure>
<p>const MyWidget(text: ‘Hello’); &#x2F;&#x2F; ✅ 优化<br>MyWidget(text: ‘Hello’);      &#x2F;&#x2F; ❌ 非 const</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**2.合理使用 Key：** ValueKey：在列表项中标识唯一性，避免错误复用导致状态混乱。</span><br><span class="line">GlobalKey：跨组件访问状态（谨慎使用，破坏局部性）。</span><br></pre></td></tr></table></figure>
<p>ListView.builder(<br>  itemBuilder: (_, index) &#x3D;&gt; ItemWidget(<br>    key: ValueKey(items[index].id), &#x2F;&#x2F; 唯一标识<br>    data: items[index],<br>  ),<br>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**3.拆分细粒度 Widget：** 将频繁变化的部分拆分为独立 Widget，缩小 setState 触发的 Diff 范围。</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 父组件（仅传递静态数据）<br>class ParentWidget extends StatelessWidget {<br>  const ParentWidget({super.key});<br>  @override<br>  Widget build(BuildContext context) {<br>    return Column(<br>      children: [<br>        const StaticHeader(), &#x2F;&#x2F; 静态部分<br>        DynamicContent(data: _data), &#x2F;&#x2F; 动态部分<br>      ],<br>    );<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**2.布局（Layout）阶段优化**</span><br><span class="line"></span><br><span class="line">&gt;**布局计算机制：** 当某个 RenderObject 的尺寸变化不影响父节点布局时，可标记为布局边界，阻断布局计算向上传播。通过 RenderObject.isRepaintBoundary = true 设置（布局边界（Relayout Boundary））</span><br><span class="line"></span><br><span class="line">&gt;父节点传递 约束（Constraints） 给子节点</span><br><span class="line">子节点根据约束计算自身尺寸，并递归布局子节点(布局过程)</span><br><span class="line"></span><br><span class="line">**优化策略**</span><br><span class="line">&gt;**1.避免过度嵌套：** 多层 Row/Column 会导致布局计算复杂度呈指数增长。</span><br><span class="line">我们可以使用 Flex、Wrap 或自定义布局逻辑替代嵌套。</span><br><span class="line"></span><br><span class="line">&gt;**2.预计算尺寸：** 通过固定尺寸（SizedBox）或 LayoutBuilder 提前确定布局约束，减少计算量。</span><br></pre></td></tr></table></figure>
<p>SizedBox(<br>  width: 100,<br>  height: 50,<br>  child: Text(‘Fixed Size’),<br>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;**3.使用 IntrinsicWidth/IntrinsicHeight 的替代方案：**     IntrinsicWidth 会触发多次子节点布局计算，性能低下。</span><br><span class="line">我们可以手动计算子节点最大宽度，使用 ConstrainedBox 限制尺寸。</span><br><span class="line"></span><br><span class="line">**3.绘制（Paint）阶段优化**</span><br><span class="line"></span><br><span class="line">&gt;**绘制机制：** 当 RenderObject 的视觉属性（如颜色、位置）变化时，调用 markNeedsPaint() 标记需要重绘。</span><br><span class="line"></span><br><span class="line">&gt;**合成层（Layer）：** 每个 RenderObject 的绘制结果被组织为 Layer 树，最终由 GPU 光栅化。（PictureLayer（矢量绘制）、TextureLayer（图像）、TransformLayer（变换））。</span><br><span class="line"></span><br><span class="line">**优化策略**</span><br><span class="line">&gt;**1.使用 RepaintBoundary：** 将独立变化的 UI 部分包裹 RepaintBoundary，生成独立 Layer，减少重绘区域。</span><br><span class="line">通过 RenderObject.isRepaintBoundary = true 标记。</span><br></pre></td></tr></table></figure>
<p>RepaintBoundary(<br>  child: MyAnimatedWidget(), &#x2F;&#x2F; 独立重绘区域<br>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;**2.避免高开销绘制操作：** 使用 AnimatedOpacity 或直接设置颜色透明度（Color.withOpacity）替代Opacity 。</span><br><span class="line">优先使用 ClipRect 或 ClipRRect，减少路径裁剪的计算量。</span><br><span class="line"></span><br><span class="line">&gt;**3.自定义绘制优化：** 在 CustomPainter 中精确控制重绘条件。</span><br></pre></td></tr></table></figure>
<p>class MyPainter extends CustomPainter {<br>  @override<br>  bool shouldRepaint(MyPainter old) {<br>    return old.color !&#x3D; color; &#x2F;&#x2F; 仅颜色变化时重绘<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**4.GPU 合成与光栅化优化**</span><br><span class="line"></span><br><span class="line">&gt;**1.光栅化机制：** 通过上面的合成与光栅化可知道：光栅化运行在独立的 Raster Thread，与 UI Thread 并行。</span><br><span class="line">Flutter 自动复用未变化的 Layer 对应的 GPU 纹理，减少数据传输。（纹理（Texture）复用）</span><br><span class="line"></span><br><span class="line">**优化策略**</span><br><span class="line"></span><br><span class="line">&gt;**1.减少 Layer 数量：** 过多的 Layer 会增加 GPU 合成开销，我们需要尽可能的合并相邻的 PictureLayer，避免不必要的 Opacity 或 Transform 嵌套。</span><br><span class="line"></span><br><span class="line">&gt;**2.使用硬件加速操作：** 利用 GPU 的矩阵变换硬件加速（Transform 替代手动矩阵计算）。</span><br><span class="line">对重复使用的图片提前解码（precacheImage） （Image 预加载）。</span><br><span class="line"></span><br><span class="line">&gt;**3.启用 Impeller 引擎：** Flutter 3.0+ 引入的 Impeller 引擎针对 GPU 负载优化，减少光栅化抖动。</span><br><span class="line"></span><br><span class="line">**5.状态管理与资源优化**</span><br><span class="line"></span><br><span class="line">&gt;**1.状态管理：**</span><br><span class="line">局部状态：使用 StatefulWidget 管理，确保 dispose() 释放资源。</span><br><span class="line">&gt;全局状态：采用 Provider、Riverpod 或 Bloc，避免状态穿透和冗余重建。</span><br><span class="line"></span><br><span class="line">&gt;**2.资源释放：**</span><br><span class="line">必须释放动画控制器（AnimationController.dispose()）、Stream 订阅（Subscription.cancel()）等资源。</span><br></pre></td></tr></table></figure>
<p>@override<br>void dispose() {<br>  _controller.dispose();<br>  _streamSubscription.cancel();<br>  super.dispose();<br>}</p>
<pre><code>![2025-05-23 14.45.52.png](https://i-blog.csdnimg.cn/img_convert/58ae194fbfc28292a73f2130d949f78a.webp?x-oss-process=image/format,png)
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/06/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
